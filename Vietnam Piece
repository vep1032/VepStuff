--THIS SCRIPT IS PATCHED AND DOES NOT WORK ANYMORE WHATSOEVER



































getgenv().MIGHTYOMEGA = true 

if game.GameId == 1663370770 and game.PlaceId ~= 12355185014 and getgenv().MIGHTYOMEGA == true then

    if not game:IsLoaded() then
        game.Loaded:Wait()
    end

    while not game:GetService("Workspace") do
        task.wait()
    end

    local player = game.Players.LocalPlayer

    while not player do task.wait()
        player = game.Players.LocalPlayer
    end

    local character = player.Character or player.CharacterAdded:Wait()

    while not character do task.wait()
        character = player.Character
    end

    local hrp = character:FindFirstChild("HumanoidRootPart")

    while not hrp do task.wait()
        hrp = character:FindFirstChild("HumanoidRootPart")
    end

    local humanoid = character:FindFirstChildOfClass("Humanoid")

    while not humanoid do task.wait()
        humanoid = character:FindFirstChildOfClass("Humanoid")
    end

    local cloneref = cloneref or nil

    local vim
    if cloneref then
        vim = cloneref(game:GetService("VirtualInputManager"))
        while not vim do task.wait()
            vim = cloneref(game:GetService("VirtualInputManager"))
        end
    else
        vim = game:GetService("VirtualInputManager")
        while not vim do task.wait()
            vim = game:GetService("VirtualInputManager")
        end
    end

    local PathfindingService = game:GetService("PathfindingService")
    local Players = game:GetService("Players")
    local RunService = game:service"RunService"

    local OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/vep1032/VepStuff/main/DRCO"))()
    local Window = OrionLib:MakeWindow({Name = "Mighty Omega | Draco Hub", HidePremium = false, SaveConfig = true,IntroEnabled = false,  ConfigFolder = "MightyOmegaConfig"})
    local coreGui = game:GetService("CoreGui")
    local hiddenUI = coreGui:FindFirstChild("HiddenUI")
    local parentUI = hiddenUI or coreGui
    local orionUI = hiddenUI and hiddenUI:FindFirstChild("Orion") or coreGui:FindFirstChild("Orion")

    local function SaveCfg(Name)
        local Data = {}
        for i,v in pairs(OrionLib.Flags) do
            if v.Save then
                if v.Type == "Colorpicker" then
                    Data[i] = PackColor(v.Value)
                else
                    Data[i] = v.Value
                end
            end	
        end
        writefile("MightyOmegaConfig" .. "/" .. Name .. ".txt", tostring(game:service"HttpService":JSONEncode(Data)))
    end

    game:service"Players".PlayerRemoving:Connect(function(plr)
        if plr == player then
            SaveCfg(game.PlaceId)
        end
    end)

    getgenv().spConn = nil
    getgenv().ssConn = nil

    local main = Window:MakeTab({
        Name = "Training",
        Icon = "rbxassetid://4483345998", 
        PremiumOnly = false
    })

    local mainset = Window:MakeTab({
        Name = "Training Setting's",
        Icon = "rbxassetid://4483345998", 
        PremiumOnly = false
    })

    local notify = Window:MakeTab({
        Name = "Notify",
        Icon = "rbxassetid://4483345998", 
        PremiumOnly = false
    })

    local autocook = Window:MakeTab({
        Name = "Auto Cook",
        Icon = "rbxassetid://4483345998", 
        PremiumOnly = false
    })

    local misc = Window:MakeTab({
        Name = "Misc",
        Icon = "rbxassetid://4483345998", 
        PremiumOnly = false
    })

    local risky = Window:MakeTab({
        Name = "Risky",
        Icon = "rbxassetid://4483345998", 
        PremiumOnly = false
    })

    risky:AddLabel("Anything in this tab was suggested by someone else")
    risky:AddLabel("Use at your own risk as these features are considered risky")
        
    local function SimulateClick(button,cmd)
        pcall(function()
            local string = {
                ha = "MouseButton1Click",
                ez = "MouseButton1Down",
                la = "Activated",
            }
            for i,v in pairs(string) do
                for i,v in pairs(getconnections(button[v])) do
                    v[cmd]()
                end
            end
        end)
    end

    local dashFunc

    for i,v in pairs(getgc()) do
        if typeof(v) == "function" and islclosure(v) and not isexecutorclosure(v) then
            local info = getinfo(v)
            if info.name == "Dash" and getfenv(v).script == game:GetService("Players").LocalPlayer.Backpack.LocalS then
                dashFunc = v
            end
        end
    end


    useObstacleDetection = true
    local espToggles = {}
    local CESP = false
    local panicdelay = 0.5
    local panicdashdelay = 3
    local CurrentRegening = false
    local panicangle = math.random(35, 90)
    local VIM = game:GetService("VirtualInputManager")
    local panicdashdebounce = false
    local ministam = 20
    local regenstamina
    local regentoamt = 50
    local autopanic
    local UIS = game:GetService("UserInputService")
    local Mouse = game.Players.LocalPlayer:GetMouse()
    local holdclick
    local CurrentGanker = nil
    local currentlyviewing = nil
    local macroruin
    local playmacroruinaudio = false
    local playopssound = false
    local opjoinedsound = 93133248032532 --98451938135974
    local copjoinedsound = 5476307813--79616283404367
    local staffjoinedsound = 76424256393028--78820995273583
    local gettinggankedsound = 1843497734--85873567825777
    local streetfightersound = 1836349031
    local flowstatesound = 14145625743
    local OPsData = nil
    local highlightplayers = false
    pcall(function()
        OPsData = readfile("MOoppositions.json")
    end)
    local OPSNotifier = false
    local SleepNotifier
    local alreadynotifieduser = nil
    local macroruindebounce = false
    local NoFoodNotify
    local LogOnNoFood
    local webhookUrl
    local camera = workspace.CurrentCamera
    local rs = game:GetService("RunService")
    local ESP
    local wanted = { "Owner", "Associates.", "Mod", "Trial Mod", "sircroc!" }
    local WhitelistedStats = {
        "Durability",
        "UpperBodyMuscle",
        "RunningSpeed",
        "Fat",
        "StrikingPower",
        "StrikingSpeed",
        "LowerBodyMuscle",
        "Height",
        "Stamina",
    }
    local oldVolume = nil
    local CurrentlyPlaying = {}
    local copnotifier
    local staffnotifier
    local disableOnStaff
    local flownotifier = false
    local flowconnection = nil
    local sfnotifier = false
    local sfconnection = nil
    local acknowledged = false
    local acook = false
    local SelectedFood = ""
    local abn
    local TotalServings = 1
    local absbox
    local autotrain
    local traintype
    local trainspeed
    local isrunning = false
    local startPunching = false
    local currentcombo
    local m2already = false
    local strikepower
    local durability
    local DuraTool = ""
    local AutoWalkAfterPushedBack
    local ft
    local st
    local taketurns = false
    local durainprogress = false
    local stopAtHP = 20
    local SkillXP = false
    local AutoStop = false
    local LogOnNotEnoughMoney = false
    local WalkBackWhenFar = false
    local FatigueToStop = 65
    local LogOnFatigued = false
    local autosleepLog, autosleepRes, autosleepwalk = false, false, false
    local AutoSleepPaths = {
        ["Noi"] = {
            ["IsInsideDist"] = 90,

            ["Sequence"] = {
                CFrame.new(
                    -563.773621,
                    47.9251785,
                    -239.531036,
                    -0.023773279,
                    2.32641151e-09,
                    -0.999717355,
                    -4.37537873e-09,
                    1,
                    2.43111575e-09,
                    0.999717355,
                    4.43193793e-09,
                    -0.023773279
                ), -- NOI INSIDE
                CFrame.new(
                    -491.393372,
                    47.1251755,
                    -334.181793,
                    0.707333982,
                    5.5018571e-08,
                    0.706879497,
                    2.09656843e-08,
                    1,
                    -9.8812194e-08,
                    -0.706879497,
                    8.47134345e-08,
                    0.707333982
                ), --midpoint1
                CFrame.new(
                    -637.209961,
                    47.125164,
                    -446.7258,
                    0.0272168536,
                    7.69836674e-08,
                    0.999629557,
                    6.81569645e-09,
                    1,
                    -7.71977682e-08,
                    -0.999629557,
                    8.91425156e-09,
                    0.0272168536
                ), --HospitalLoaded
            },
        },

        ["Karate"] = {
            ["IsInsideDist"] = 90,

            ["Sequence"] = {
                CFrame.new(
                    -664.119202,
                    47.6938782,
                    -611.250977,
                    -0.00150513474,
                    -8.3909228e-08,
                    0.999998868,
                    1.02445374e-09,
                    1,
                    8.39108623e-08,
                    -0.999998868,
                    1.15074972e-09,
                    -0.00150513474
                ), -- karate inside
                CFrame.new(
                    -725.983948,
                    47.7645721,
                    -574.489563,
                    -0.999990106,
                    -5.69174006e-08,
                    0.00445292145,
                    -5.67966332e-08,
                    1,
                    2.7247351e-08,
                    -0.00445292145,
                    2.69941687e-08,
                    -0.999990106
                ), --midpoint1
                CFrame.new(
                    -726.560303,
                    46.7939758,
                    -458.533325,
                    -0.896284282,
                    -4.07478096e-09,
                    0.443480015,
                    -3.75909188e-08,
                    1,
                    -6.6783997e-08,
                    -0.443480015,
                    -7.65282664e-08,
                    -0.896284282
                ), --HospitalLoaded
            },
        },
    }
    local trainingsTodo = {}
    local enabledToggles = {}
    local sleepanims = {
        "rbxassetid://5110906576",
        "rbxassetid://4959794246",
        "rbxassetid://5110983609",
        "rbxassetid://4959795216",
        "rbxassetid://4959793113",
        "rbxassetid://5110953707",
        "rbxassetid://5110982040",
        "rbxassetid://5110919996",
    }
    local disabledFeaturesRunning = false
    local ESPDistance = 10000
    local strikespeed = false
    local rhythmcheckdebounce = false
    local autoeat = false
    local stopAEinCombat = false
    local FillUp
    local EatAt
    local autosupplement = false
    local selectedsupplement = nil
    local machines = false
    local treadselect = nil
    local machinetype = nil
    local CurrentRegening = false
    local ping = "@everyone"
    local statcheck = false
    local RhythmToggle = false
    local RunToPercent = 50
    local waittostamina = 70
    local PunchStartPercent = 55
    local PunchEndPercent = 20
    local Roadwork = false
    local RWCanSprint = false
    local CPRangeTilNext = 7
    local PointRangeTilNext = 6
    local m1speedslider = 0.1
    local DrinkAmm = 1
    local LastMachine = nil
    local spuseM2 = false
    local ssuseM2 = false
    local autostarve = false
    local staminabelowpercent = 20
    local ASisrunning = false
    local PFS = game:GetService("PathfindingService")
    local HRP = game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local pathStatus = Enum.PathStatus
    local player = game.Players.LocalPlayer
    local autobuyitem = false
    local itemselected = nil
    local StopInCombat = false
    local StopKnocked = false
    local autosprintcombat = false
    local holdingW = false
    local disableall = false
    local began, ended = nil, nil
    local moveto, donebuying = false, false
    local buydistances = 60
    task.spawn(function()
    local dontopen = false
    local Folder = Instance.new("Folder", Workspace)
    Folder.Name = "Waypoints"
    end)
    shared.currentPoint = nil
    local MOfoods = {
        "Donut",
        "Coffee",
        "Bagel",
        "EZ Taco",
        "Omelette",
        "Hotdog",
        "Pancakes",
        "Tofu Beef Soup",
        "Pie",
        "Tokito Sake",
        "Hamburger",
        "Chicken Fries",
        "Ramen",
        "Chicken",
        "Curry",
        "Steak",
        "Steak Fried Rice",
        "Braised Potatoes",
        "Sunny side up egg",
        "Onigiri",
        "Marinade Lobster",
    }
    local recipes = {
        ["Steak"] = {
            ["Seasoning"] = 1,
            ["Raw Beef"] = 1,
        },
        ["Chicken"] = {
            ["Seasoning"] = 1,
            ["Raw Chicken"] = 1,
        },
        ["Sunny Side up Egg"] = {
            ["Egg"] = 1,
        },
        ["Onigri"] = {
            ["Rice"] = 2,
            ["Seasoning"] = 1,
            ["Seaweed"] = 1,
            ["Soy Sauce"] = 1,
        },
        ["Omelette"] = {
            ["Egg"] = 2,
            ["Seasoning"] = 1,
        },
        ["Braised Potato"] = {
            ["Potato"] = 2,
            ["Soy Sauce"] = 1,
            ["Onion"] = 1,
            ["Seasoning"] = 1,
        },
        ["Steak Fried Rice"] = {
            ["Rice"] = 1,
            ["Egg"] = 2,
            ["Onion"] = 1,
            ["Carrot"] = 1,
            ["Raw Beef"] = 1,
            ["Tomato"] = 1,
            ["Seasoning"] = 1,
            ["Spice"] = 1,
        },
        ["Curry"] = {
            ["Spice"] = 1,
            ["Potato"] = 1,
            ["Carrot"] = 1,
            ["Raw Beef"] = 1,
            ["Rice"] = 2,
            ["Onion"] = 1,
        },
        ["Marinade Lobster"] = {
            ["Seasoning"] = 1,
            ["Raw Lobster"] = 1,
            ["Spice"] = 1,
        },
    }

    local function CheckForFood()
        if SelectedFood == nil then
            return false
        end
        for i, v in pairs(recipes[SelectedFood]) do
            if game.Players.LocalPlayer.Backpack:FindFirstChild(i) == nil then
                return false
            end
            if game.Players.LocalPlayer.Backpack:FindFirstChild(i).Quantity.Value < v then
                return false
            end
        end
        return true
    end

    local function GetItemTable()
        local tbl = {}

        for i, v in pairs(workspace.Map:GetChildren()) do
            if v:FindFirstChild("Shopnoid") or (v.Name == "Lao Stand shop") then
                if v.Name == "Lao Stand shop" then
                    for _, item in pairs(v:GetChildren()) do
                        if item.Name and item.Name:match(":") then
                            local foodname = item.Name:split(":")[1]
                            if table.find(MOfoods, foodname) then
                                table.insert(tbl, item)
                            end
                        end
                    end
                elseif v:FindFirstChild("Shopnoid") then
                    local foodname = v.Name:split(":")[1]
                    if table.find(MOfoods, foodname) then
                        table.insert(tbl, v)
                    end
                end
            end
        end
        

        return tbl
    end

    lastActionTime = nil
    local function resetTimer()
        lastActionTime = os.clock()
    end 

    local ItemTable = GetItemTable()

    local function round(n)
        return math.floor(n) * 1
    end

    local function GetPan()
        local bestdistance, pan = nil, nil
        local paninstances = {
            workspace,
            game:GetService("Workspace").Map.Apartments.Apartment2,
            game:GetService("Workspace").Map.HOMRA,
            game:GetService("Workspace").Map.Apartments.Apartment4,
            game:GetService("Workspace").Map.Apartments.Apartment1,
            game:GetService("Workspace").Map["Street House"],
            game:GetService("Workspace")["Organisation Building"],
        }

        for _, instance in pairs(paninstances) do
            for i, v in pairs(instance:GetChildren()) do
                if v.Name == "Stove" or v:FindFirstChild("Stove") then
                    if v:FindFirstChild("Stove") then
                        v = v:FindFirstChild("Stove")
                    end

                    local distance = (
                        v.PanModel.FoodP.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position
                    ).Magnitude

                    if bestdistance == nil and distance <= 5 then
                        bestdistance = distance
                        pan = v.PanModel
                    elseif bestdistance ~= nil and distance <= 5 then
                        if bestdistance > distance and distance <= 5 then
                            bestdistance = distance
                            pan = v.PanModel
                        end
                    end
                end
            end
        end
        return pan
    end



    local function playsound(id)
        local sound = Instance.new("Sound", game.CoreGui)
        sound.SoundId = "rbxassetid://" .. id
        sound.Volume = 10
        sound.Looped = true
        sound:Play()
        return sound
    end

    local function createPath(point)
        local currentPath = PFS:ComputeAsync(HRP.Position, point)
        local pathExists = false

        if currentPath.Status == pathStatus.Success then
            pathExists = true

            spawn(function()
                while pathExists and task.wait() and Roadwork and shared.currentPoint ~= nil do
                    player.Character.Humanoid:MoveTo(shared.currentPoint)
                end
            end)

            for i, v in pairs(currentPath:GetWaypoints()) do
                if Roadwork == false then
                    shared.currentPoint = nil
                    break
                end
                if v.Action == Enum.PathWaypointAction.Jump then
                    task.wait()
                    Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
                repeat
                    task.wait()
                    shared.currentPoint = v.Position
                until (HRP.Position - v.Position).Magnitude < CPRangeTilNext or Roadwork == false
            end
        elseif currentPath.Status ~= pathStatus.Success or shared.currentPoint == nil then
            pathExists = false
        end
    end


    local function Callback(answer)
        acknowledged = true
        UserSettings():GetService("UserGameSettings").MasterVolume = oldVolume
        oldVolume = nil
        for i, v in pairs(CurrentlyPlaying) do
            v:Stop()
            game.Debris:AddItem(v, 0.01)
        end
        CurrentlyPlaying = {}
        task.delay(1, function()
            acknowledged = false
        end)

        if answer == "OMG FLOW" and game:GetService("Workspace"):FindFirstChild("XinFolder") then
            local QuestMarker = Instance.new("BillboardGui")
            local ImageLabel = Instance.new("ImageLabel")

            QuestMarker.Name = "ESP"
            QuestMarker.Parent = game:GetService("Workspace").XinFolder:FindFirstChildOfClass("Model").HumanoidRootPart
            QuestMarker.AlwaysOnTop = true
            QuestMarker.Size = UDim2.new(0, 50, 0, 50)

            ImageLabel.Parent = QuestMarker
            ImageLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            ImageLabel.BackgroundTransparency = 1.000
            ImageLabel.Size = UDim2.new(1, 0, 1, 0)
            ImageLabel.Image = "rbxassetid://2334137638"
            ImageLabel.ImageColor3 = Color3.fromRGB(255, 85, 0)
        elseif answer == "LIGHTWORK" and game:GetService("Workspace"):FindFirstChild("AokiFolder") then
            local QuestMarker = Instance.new("BillboardGui")
            local ImageLabel = Instance.new("ImageLabel")

            QuestMarker.Name = "ESP"
            QuestMarker.Parent = game:GetService("Workspace").AokiFolder:FindFirstChildOfClass("Model").HumanoidRootPart
            QuestMarker.AlwaysOnTop = true
            QuestMarker.Size = UDim2.new(0, 50, 0, 50)

            ImageLabel.Parent = QuestMarker
            ImageLabel.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            ImageLabel.BackgroundTransparency = 1.000
            ImageLabel.Size = UDim2.new(1, 0, 1, 0)
            ImageLabel.Image = "rbxassetid://2334137638"
            ImageLabel.ImageColor3 = Color3.fromRGB(255, 85, 0)
        end
    end
    local Bindable = Instance.new("BindableFunction")
    Bindable.OnInvoke = Callback

    local function GetSkill()
        local lol = game:GetService("Players").LocalPlayer.PlayerGui.BackpackGUI.Frame

        for i, v in pairs(lol:GetChildren()) do
            if v.ClassName == "ImageLabel" then
                if tostring(v.ImageColor3) == "0.419608, 0.32549, 0.137255" then
                    if game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool") then
                        if game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("Skill") then
                            return game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"), v
                        end
                    end
                elseif tostring(v.ImageColor3) == "0.211765, 0.211765, 0.211765" then
                    if game.Players.LocalPlayer.Backpack:FindFirstChild(v.ToolName.Text) then
                        if
                            game.Players.LocalPlayer.Backpack:FindFirstChild(v.ToolName.Text):FindFirstChild("Skill")
                        then
                            return game.Players.LocalPlayer.Backpack:FindFirstChild(v.ToolName.Text), v
                        end
                    end
                end
            end
        end

        return nil, nil
    end

    comboconnectionSP = nil
    comboconnectionss = nil

    local function disableAllTraining()
        if strikespeed then 
            enabledToggles["strikespeed"] = true; 
            strikespeed = false; 
            if comboconnectionss then
                comboconnectionss:Disconnect()
                comboconnectionss = nil
            end
        end
        if strikepower then 
            enabledToggles["strikepower"] = true; 
            strikepower = false; 
            if comboconnectionSP then
                comboconnectionSP:Disconnect()
                comboconnectionSP = nil
            end
        end
        if autotrain then enabledToggles["autotrain"] = true; autotrain = false end
        if durability then enabledToggles["durability"] = true; durability = false end
        if machines then enabledToggles["machines"] = true; machines = false end

        OrionLib:MakeNotification({
            Name = "Training Disabled",
            Content = "All training toggles have been disabled.",
            Image = "rbxassetid://4483345998",
            Time = 5
        })
    end

    local function restoreTraining()
        for toggle, _ in pairs(enabledToggles) do
            if toggle == "strikespeed" then 
                strikespeed = true; 
                comboconnectionss = game.Players.LocalPlayer.Character.ChildAdded:Connect(function(v)
                    if not strikespeed then
                        if comboconnectionss then
                            comboconnectionss:Disconnect()
                        end
                        return
                    end
                    if v.Name == "Attacking" and strikespeed then
                        currentcombo = v.Value
                    end
                end)
                ssStart()
            end
            if toggle == "strikepower" then 
                strikepower = true;
                comboconnectionSP = game.Players.LocalPlayer.Character.ChildAdded:Connect(function(v)
                    if not strikepower then
                        comboconnectionSP:Disconnect()
                        return
                    end
                    if v.Name == "Attacking" and strikepower then
                        currentcombo = v.Value
                    end
                end)
                startSp()
            end
            if toggle == "autotrain" then autotrain = true end
            if toggle == "durability" then durability = true end
            if toggle == "machines" then machines = true end
        end
        enabledToggles = {}

        OrionLib:MakeNotification({
            Name = "Training Restored",
            Content = "Previously enabled training toggles have been restored.",
            Image = "rbxassetid://4483345998",
            Time = 5
        })
    end
     
    local function Notifier(v)
        if v ~= nil then
            if v:IsInGroup(15987464) and copnotifier or v:IsInGroup(7677568) and copnotifier then
                if oldVolume == nil then
                    oldVolume = UserSettings():GetService("UserGameSettings").MasterVolume
                end
                local level = 10 / 10
                UserSettings():GetService("UserGameSettings").MasterVolume = level
                CurrentlyPlaying[#CurrentlyPlaying + 1] = playsound(copjoinedsound)

                game.StarterGui:SetCore("SendNotification", {
                    Title = "FUCK 12 (Cop)",
                    Text = v.Name,
                    Duration = math.huge,
                    Button1 = "NIII",
                    Callback = Bindable,
                })
            end

                if table.find(wanted, v:GetRoleInGroup(4800422)) and staffnotifier then
                    if disableOnStaff then
                    disableAllTraining()
                end

                if oldVolume == nil then
                    oldVolume = UserSettings():GetService("UserGameSettings").MasterVolume
                end
                local level = 10 / 10
                UserSettings():GetService("UserGameSettings").MasterVolume = level
                CurrentlyPlaying[#CurrentlyPlaying + 1] = playsound(staffjoinedsound)

                game.StarterGui:SetCore("SendNotification", {
                    Title = "Staff Joined Kid Be Careful",
                    Text = v.Name,
                    Duration = math.huge,
                    Button1 = "fuck him",
                    Callback = Bindable,
                })
                if oldVolume == nil then
                    oldVolume = UserSettings():GetService("UserGameSettings").MasterVolume
                end
            end
        else
            if game:GetService("Workspace"):FindFirstChild("XinFolder") and flownotifier then
                if oldVolume == nil then
                    oldVolume = UserSettings():GetService("UserGameSettings").MasterVolume
                end
                local level = 10 / 10
                UserSettings():GetService("UserGameSettings").MasterVolume = level
                CurrentlyPlaying[#CurrentlyPlaying + 1] = playsound(flowstatesound)

                game.StarterGui:SetCore("SendNotification", {
                    Title = "Flow NPC",
                    Text = "LUKE XIN",
                    Duration = math.huge,
                    Button1 = "no way!",
                    Callback = Bindable,
                })
            end

            if game:GetService("Workspace"):FindFirstChild("AokiFolder") and sfnotifier then
                if oldVolume == nil then
                    oldVolume = UserSettings():GetService("UserGameSettings").MasterVolume
                end
                local level = 10 / 10
                UserSettings():GetService("UserGameSettings").MasterVolume = level
                CurrentlyPlaying[#CurrentlyPlaying + 1] = playsound(streetfightersound)

                game.StarterGui:SetCore("SendNotification", {
                    Title = "SF NPC",
                    Text = "STREET FIGHTER",
                    Duration = math.huge,
                    Button1 = "free asf",
                    Callback = Bindable,
                })
            end
        end
    end

    game:GetService("Workspace").Live.DescendantAdded:Connect(function(child)
        if child.Name == "Attacking" and child.Parent ~= game.Players.LocalPlayer.Character and macroruin then
            local playerCharacter = game.Players.LocalPlayer.Character
            if playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart") and child.Parent:FindFirstChild("HumanoidRootPart") then
                local distance = (child.Parent.HumanoidRootPart.Position - playerCharacter.HumanoidRootPart.Position).Magnitude
                if distance <= 5 then
                    local playerListGui = game.Players.LocalPlayer.PlayerGui:FindFirstChild("PlayerList")
                    if playerListGui and playerListGui:FindFirstChild("Main") and playerListGui.Main:FindFirstChild("SF") then
                        local holder = playerListGui.Main.SF:FindFirstChild("Holder")
                        if holder then
                            local playerLabel = holder:FindFirstChild(child.Parent.Name)
                            if playerLabel then
                                CurrentGanker = playerLabel.Player.Title.Text .. " [" .. child.Parent.Name .. "]"
                            end
                        end
                    end
                end
            end
        end
    end)
    
    if getgenv().spectateList == nil then
        getgenv().spectateList = true

        task.spawn(function()
            local gankedLists = {}
            local plrList = game:GetService("Players").LocalPlayer.PlayerGui.PlayerList.Main.SF.Holder

            while spectateList and task.wait() do
                pcall(function()
                    if game.Players.LocalPlayer.PlayerGui:FindFirstChild("PlayerList") ~= nil then
                        plrList = game:GetService("Players").LocalPlayer.PlayerGui.PlayerList.Main.SF.Holder

                        if gankedLists[plrList] ~= true then
                            gankedLists[plrList] = true
                            repeat
                                task.wait()
                            until game:IsLoaded() and game.Players.LocalPlayer.Character ~= nil
                            repeat
                                task.wait()
                            until game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

                            for i, v in pairs(plrList:GetChildren()) do
                                if v:IsA("ImageButton") and v.Name ~= game.Players.LocalPlayer.Name then
                                    v.User.Activated:Connect(function()
                                        if currentlyviewing ~= nil then
                                            if currentlyviewing:FindFirstChild("Player") ~= nil then
                                                if currentlyviewing == v then
                                                    currentlyviewing.Player.Title.TextColor3 = Color3.fromRGB(255, 255, 255)
                                                    workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:WaitForChild("Humanoid")
                                                    currentlyviewing = nil
                                                    return
                                                end
                                                currentlyviewing.Player.Title.TextColor3 = Color3.fromRGB(255, 255, 255)
                                            elseif currentlyviewing:FindFirstChild("Player") == nil then
                                                workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:WaitForChild("Humanoid")
                                                currentlyviewing = nil
                                            end
                                        end

                                        local viewplr = workspace.Live:FindFirstChild(v.Name)
                                        if viewplr == nil then
                                            return
                                        end
                                        if viewplr:FindFirstChild("Humanoid") ~= nil then
                                            workspace.CurrentCamera.CameraSubject = viewplr:WaitForChild("Humanoid")
                                            v.Player.Title.TextColor3 = LibraryColor
                                            currentlyviewing = v
                                            task.spawn(function()
                                                while (currentlyviewing == v) and task.wait(0.5) do
                                                    local viewplr = workspace.Live:FindFirstChild(v.Name)
                                                    if viewplr == nil then
                                                        workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:WaitForChild("Humanoid")
                                                        currentlyviewing = nil
                                                        break
                                                    end
                                                end
                                            end)
                                        end
                                    end)
                                end
                            end

                            plrList.ChildAdded:Connect(function(v)
                                    if v:IsA("ImageButton") and v.Name ~= game.Players.LocalPlayer.Name then
                                    v.User.Activated:Connect(function()
                                        if currentlyviewing ~= nil then
                                            if currentlyviewing:FindFirstChild("Player") ~= nil then
                                                if currentlyviewing == v then
                                                    currentlyviewing.Player.Title.TextColor3 = Color3.fromRGB(255, 255, 255)
                                                    workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:WaitForChild("Humanoid")
                                                    currentlyviewing = nil
                                                    return
                                                end
                                                currentlyviewing.Player.Title.TextColor3 = Color3.fromRGB(255, 255, 255)
                                            elseif currentlyviewing:FindFirstChild("Player") == nil then
                                                workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:WaitForChild("Humanoid")
                                                currentlyviewing = nil
                                            end
                                        end

                                        local viewplr = workspace.Live:FindFirstChild(v.Name)
                                        if viewplr == nil then
                                            return
                                        end
                                        if viewplr:FindFirstChild("Humanoid") ~= nil then
                                            workspace.CurrentCamera.CameraSubject = viewplr:WaitForChild("Humanoid")
                                            v.Player.Title.TextColor3 = LibraryColor
                                            currentlyviewing = v
                                            task.spawn(function()
                                                while (currentlyviewing == v) and task.wait(0.5) do
                                                    local viewplr = workspace.Live:FindFirstChild(v.Name)
                                                    if viewplr == nil then
                                                        workspace.CurrentCamera.CameraSubject =
                                                            game.Players.LocalPlayer.Character:WaitForChild("Humanoid")
                                                        currentlyviewing = nil
                                                        break
                                                    end
                                                end
                                            end)
                                        end
                                    end)
                                end
                            end)
                        end
                    end
                end)
            end
        end)
    end


    function round(p8, p9)
        if not p9 then
            return math.floor(p8 + 0.5)
        end
        local v15 = math.floor(p8 * 10 ^ p9 + 0.5) / 10 ^ p9
        local v16 = string.len(v15)
        local v17 = string.sub(v15, v16, v16)
        local v18 = v16 - 1
        if string.sub(v15, v18, v18) == "." then
            v15 = v15 .. "0"
        end
        return v15
    end
    
    if typeof(getgc) ~= "nil" then
        local StatViewerLabels = nil
        local SC = Window:MakeTab({Name = "Stat Check", Icon = "rbxassetid://4483345998", PremiumOnly = false})
    
        shared.StatUpdate = function(v)
            if statcheck ~= true then
                return
            end
    
            if not v or typeof(v) ~= "table" then
                warn("Invalid StatTable data")
                return
            end
    
            -- Initialize StatViewerLabels if it doesn't exist
            StatViewerLabels = StatViewerLabels or {}
    
            -- Update all stats dynamically
            for i, statValue in pairs(v) do
                if table.find(WhitelistedStats, i) then
                    local displayValue
    
                    -- Check if the stat is a table or number
                    if typeof(statValue) == "table" and statValue[1] then
                        displayValue = round(statValue[1], 3)
                    elseif typeof(statValue) == "number" then
                        displayValue = round(statValue, 3)
                    else
                        displayValue = tostring(statValue) -- Fallback for unexpected types
                    end
    
                    -- Update label or create a new one
                    if StatViewerLabels[i] then
                        StatViewerLabels[i]:Set(i .. " - " .. displayValue)
                    else
                        StatViewerLabels[i] = SC:AddLabel(i .. " - " .. displayValue)
                    end
                end
            end
        end
    
        local function StatTable()
            local ls = game.Players.LocalPlayer.Backpack:FindFirstChild("LocalS")
            if not ls then
                warn("LocalS script not found in Backpack")
                return nil
            end
    
            ls = getsenv(ls)
            for _, v in pairs(ls) do
                if typeof(v) == "function" then
                    for _, upval in pairs(debug.getupvalues(v)) do
                        if typeof(upval) == "table" and upval["Height"] then
                            return upval
                        end
                    end
                end
            end
            warn("Stat table not found")
            return nil
        end
    
        SC:AddToggle({
            Name = "Auto Stat Check",
            Default = false,
            Callback = function(Value)
                statcheck = Value
                if statcheck then
                    shared.StatUpdate(StatTable())
                end
            end
        })
    
        SC:AddToggle({
            Name = "Refresh Constantly",
            Default = false,
            Callback = function(Value)
                RefreshConstant = Value
                while RefreshConstant and task.wait(0.1) do
                    shared.StatUpdate(StatTable())
                end
            end
        })
    
        if not shared.StatConfigured then
            task.spawn(function()
                shared.StatConfigured = true
                local updateDebounce = false
                game:GetService("ReplicatedStorage").Events.UpdateStats.OnClientEvent:Connect(function()
                    if not updateDebounce and statcheck then
                        updateDebounce = true
                        pcall(function()
                            shared.StatUpdate(StatTable())
                        end)
                        task.wait(0.1)
                        updateDebounce = false
                    end
                end)
            end)
        end
    end
    



    local function GetBed()
        local bestdistance, bed = math.huge, nil
    
        for _, v in pairs(game:GetService("Workspace"):GetChildren()) do
            if v.Name:find("Bed") and not v:FindFirstChild("OccupiedBy") then
                local distance = (v.Matress.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                if distance < bestdistance then
                    bestdistance = distance
                    bed = v
                end
            end
        end
    
        if bed == nil then
            for _, v in pairs(game:GetService("Workspace"):GetChildren()) do
                if v.Name:find("Map") then
                    for i, x in pairs(v.Apartments:GetChildren()) do
                        if x.Name:find("Apartment") then
                            for _, bedObject in pairs(x:GetDescendants()) do
                                if bedObject.Name == "Bed" and bedObject.Parent:IsA("Model") then
                                    local distance = (bedObject.Matress.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                                    local Owner = bedObject:FindFirstChild("Owner") and bedObject.Owner.Value or nil
                                    if Owner == tostring(game.Players.LocalPlayer.UserId) then
                                        return bedObject
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    
        return bed
    end
    
    local function GetMachineType(v)
        if v:FindFirstChild("Screen") then
            return "Treadmill"
        elseif v:FindFirstChildOfClass("MeshPart") and v:FindFirstChild("Barbell") then
            return "Bench"
        elseif not v:FindFirstChildOfClass("MeshPart") and v:FindFirstChild("Barbell") then
            return "Squat"
        else
            return "nil"
        end
    end

    local function get_lowest_val(t)
        local _, idx = nil, nil
        for i,v in pairs(t) do
            if type(v) == "number" then
                if _ ~= nil then
                    if v < _ then
                        _ = v
                        idx = i
                    end
                else
                    _ = v
                    idx = i
                end
            end
        end
        return _, idx
    end

    local function ClosestMachine()
        local bestdistance, machine = nil, nil
        local machineinstances =
            { workspace.Naniwa, workspace["Organisation Building"], workspace.Map, workspace:GetChildren()[1436] }

        for _, instance in pairs(machineinstances) do
            for i, v in pairs(instance:GetChildren()) do
                if GetMachineType(v) == machinetype and v.Name == "Machine" then
                    if v:FindFirstChild("Machine") then
                        v = v:FindFirstChild("Machine")
                    end
                    local distance = (v.Base.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    local MaxActivationDist = v.ClickDetector.MaxActivationDistance

                    if distance <= MaxActivationDist then
                        if bestdistance == nil and machine == nil then
                            bestdistance = distance
                            machine = v
                        elseif bestdistance > distance then
                            bestdistance = distance
                            machine = v
                        end
                    end
                end
            end
        end

        return machine
    end

    local function ChargeRhythm(combatTool)
        if not RhythmToggle then
            return
        end

        if game.Players.LocalPlayer.Character.HumanoidRootPart.RhythmUI.Enabled == false and combatTool.Parent == game.Players.LocalPlayer.Character
        then
            VIM:SendKeyEvent(true, "R", false, game)
            task.wait(0.1)
        elseif
            game.Players.LocalPlayer.Character.HumanoidRootPart.RhythmUI.Enabled == true
            and combatTool.Parent == game.Players.LocalPlayer.Character
            and game.Players.LocalPlayer.Character.Rhythm.Value ~= 100
            and not rhythmcheckdebounce
        then
            rhythmcheckdebounce = true
            task.spawn(function()
                local oldRhythm = game.Players.LocalPlayer.Character.Rhythm.Value
                task.wait(0.1)
                if game.Players.LocalPlayer.Character.Rhythm.Value < oldRhythm then
                    VIM:SendKeyEvent(true, "R", false, game)
                    task.wait(0.1)
                    oldRhythm = game.Players.LocalPlayer.Character.Rhythm.Value
                    repeat
                        task.wait()
                    until game.Players.LocalPlayer.Character.Rhythm.Value == 100
                        or game.Players.LocalPlayer.Character.Rhythm.Value < oldRhythm
                        or combatTool.Parent ~= game.Players.LocalPlayer.Character
                else
                    repeat
                        task.wait()
                    until game.Players.LocalPlayer.Character.Rhythm.Value == 100
                        or game.Players.LocalPlayer.Character.Rhythm.Value < oldRhythm
                        or combatTool.Parent ~= game.Players.LocalPlayer.Character
                end
                rhythmcheckdebounce = false
            end)
        end
    end

    local function IsSleeping()
        for i, v in pairs(game.Players.LocalPlayer.Character.Humanoid:GetPlayingAnimationTracks()) do
            if table.find(sleepanims, v.Animation.AnimationId) then
                return true
            end
        end
        return false
    end

    local function webhook(title, desc, important)
        pcall(function()
            local url = webhookUrl 
            print("webhook?")
            if url == "" then
                return
            end

            local data

            data = {
                ["content"] = ping .. " Say Bismillah!",
                ["username"] = "Draco Hub!",
                ["avatar_url"] = "https://cdn.discordapp.com/attachments/1217810814808100864/1311374885519626292/40xf09fa4ac.webp?ex=6748a088&is=67474f08&hm=7fb5f8a50fd943873502273a86acdc73ae7159195c5dd507112a1107756159c6&",
                ["embeds"] = {
                    {
                        ["author"] = {
                            ["name"] = "Mighty Omega | " .. title,
                            ["icon_url"] = "https://cdn.discordapp.com/attachments/1217810814808100864/1311374880222216283/sticker.png?ex=6748a087&is=67474f07&hm=872700320dfda92393373f163671b0b7219a4b57c6d3d4804fefa67216104eba&",
                        },
                        ["description"] = desc,
                        ["color"] = 110335,
                    },
                },
            }

            local porn = game:GetService("HttpService"):JSONEncode(data)

            local headers = { ["content-type"] = "application/json" }
            request = http_request or request or HttpPost or syn.request or http.request
            local sex = { Url = url, Body = porn, Method = "POST", Headers = headers }
            warn("Sending webhook notification...")
            request(sex)
        end)
    end

    noCornerCf = CFrame.new(-838.739197, 47.1977577, -245.373322, 0.0195821822, 3.97637692e-08, 0.999808252, -2.6600862e-08, 1, -3.92503949e-08, -0.999808252, -2.58271537e-08, 0.0195821822)
    noCornerCf2 = CFrame.new(-838.868164, 47.1977844, -232.582703, 0.0178169515, -7.98227973e-08, 0.999841273, 6.81932306e-08, 1, 7.86202818e-08, -0.999841273, 6.67816309e-08, 0.0178169515)

    --[[
    corner1 = Instance.new("Part")
    corner1.CanCollide = false
    corner1.Size = Vector3.new(2, 1, 2)
    corner1.Position = noCornerCf.Position

    corner2 = Instance.new("Part")
    corner2.CanCollide = false
    corner2.Size = Vector3.new(2, 1, 2)
    corner2.Position = noCornerCf2.Position

    modifierVolume = corner
    modifier = Instance.new("PathfindingModifier", modifierVolume)
    modifier.ModifierId = "Corner"
    modifier.Parent = corner1
    modifierVolume2 = corner2
    modifier2 = Instance.new("PathfindingModifier", modifierVolume2)
    modifier2.ModifierId = "Corner"
    modifier2.Parent = corner2
    -]]

    function setCameraSubject(subject)
	    workspace.CurrentCamera.CameraSubject = subject;
	end

    local function sleepWalk(point)
        print("[1] Starting sleepWalk function")
        
        task.spawn(function()
            shared.AllowSprinting = false
    
            while task.wait(0.1) and autosleepwalk do
                pcall(function()
                    local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack:FindFirstChild("LocalS"))
                    local StamPercent = (
                        game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                    local LowStam = ministam
    
                    if isrunning == false and StamPercent >= 100 and shared.AllowSprinting then
                        actionscript.runPrompt()
                        isrunning = true
                        task.wait(1)
                    elseif isrunning == true and shared.AllowSprinting then
                        repeat StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value/ game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                            task.wait()
                        until StamPercent <= LowStam
                            or StamPercent == 100
                            or autosleepwalk == false
                            or shared.AllowSprinting == false
    
                        actionscript.stopSprint()
                        isrunning = false
                    elseif isrunning == true and shared.AllowSprinting == false then
                        actionscript.stopSprint()
                        isrunning = false
                    end
                end)
            end
    
            shared.AllowSprinting = false
        end)

        -- Validate character components
        local plr = game:GetService("Players").LocalPlayer
        local char = plr.Character
        if not char then
            warn("[Error] Character not found")
            return false
        end
        local PFS = game:GetService("PathfindingService")
        local hum = char:FindFirstChild("Humanoid")
        local HRP = char:FindFirstChild("HumanoidRootPart")

        if not hum or not HRP then
            warn("[Error] Missing Humanoid or HRP")
            return false
        end
    
        print("[2] Character validation passed")
    
        -- Validate target point
        if not point or not point.Position then
            warn("[Error] Invalid target point")
            return false
        end
    
        print("[3] Target validation passed - Target position:", point.Position)
    
        -- Pathfinding setup
        print("[4] Starting pathfinding process")
        print("Start Position:", HRP.Position)
        print("Target Position:", point.Position)

        local function createNewPath()
            return PFS:CreatePath({
                AgentRadius = 1.5,
                AgentHeight = 5,
                AgentCanJump = true,
                AgentJumpHeight = hum.JumpHeight,
                AgentMaxSlope = hum.MaxSlopeAngle,
                WaypointSpacing = 2
            })
        end

        local currentPath = createNewPath()
        local retries = 0
        local lastJumpTime = 0
        local TimesBroken = 0
        local lastValidPosition = HRP.Position
        local lastPositionCheck = tick()
        local useOldMethod = false 
        MAX_RETRIES = 5

        repeat
            local success = pcall(function()
                currentPath:ComputeAsync(HRP.Position, point.Position)
            end)
            retries = retries + 1
            if not success and retries >= MAX_RETRIES then
                print("Pathfinding failed after multiple attempts")
                return false
            end
            task.wait(0.5)
        until currentPath.Status == Enum.PathStatus.Success

        print("Path found successfully.")
        _G.OngoingPath = true
        
        local function checkObstacleAhead()
            local raycastParams = RaycastParams.new()
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
            raycastParams.FilterDescendantsInstances = {char}
            
            -- Cast three rays: center, left, and right
            local centerRay = workspace:Raycast(
                HRP.Position,
                HRP.CFrame.LookVector * 5,
                raycastParams
            )
            
            local rightRay = workspace:Raycast(
                HRP.Position,
                (HRP.CFrame * CFrame.Angles(0, math.rad(30), 0)).LookVector * 5,
                raycastParams
            )
            
            local leftRay = workspace:Raycast(
                HRP.Position,
                (HRP.CFrame * CFrame.Angles(0, math.rad(-30), 0)).LookVector * 5,
                raycastParams
            )
    
            return {
                center = centerRay,
                right = rightRay,
                left = leftRay
            }
        end
    
        -- Improved obstacle avoidance logic
        local function avoidObstacle()
            local rays = checkObstacleAhead()
            local moveDirection = nil
            
            -- Calculate obstacle position relative to character
            if rays.center then
                local obstaclePosition = rays.center.Position
                local toObstacle = (obstaclePosition - HRP.Position).Unit
                local rightDot = toObstacle:Dot(HRP.CFrame.RightVector)
                
                -- Determine best avoidance direction
                if rightDot > 0 then
                    -- Obstacle is on the right, move left
                    moveDirection = HRP.CFrame.LeftVector * 3
                else
                    -- Obstacle is on the left, move right
                    moveDirection = HRP.CFrame.RightVector * 3
                end
                
                -- Verify clearance in chosen direction
                local clearanceRay = workspace:Raycast(
                    HRP.Position,
                    moveDirection,
                    raycastParams
                )
                
                if not clearanceRay then
                    return moveDirection
                end
            end
            
            -- Fallback to smart direction choice
            if rays.left and not rays.right then
                return HRP.CFrame.RightVector * 3
            elseif rays.right and not rays.left then
                return HRP.CFrame.LeftVector * 3
            end
            
            -- If both sides blocked, jump
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
            return nil
        end

        -- Improved movement task
        task.spawn(function()
            while _G.OngoingPath and autosleepwalk do
                pcall(function()
                    if (HRP.Position - _G.currentPoint).Magnitude > 2.5 then
                        hum:MoveTo(_G.currentPoint)
                        if useObstacleDetection then
                            if checkObstacleAhead().center then
                                local avoidanceVector = avoidObstacle()
                                if avoidanceVector then
                                    local targetPosition = HRP.Position + avoidanceVector
                                    hum:MoveTo(targetPosition)
                                    hum.MoveToFinished:Wait()
                                end
                            end
                        end
                    end
                end)
                task.wait(0.1)
            end
        end)


        local lastbroken, LBinit, NotMoving = false, false, false
        local oldhumanpos, lastupdate = nil, nil
        local jumpDebounce = false
        local useOldMethod, TimesBroken, verifiedMoving = false, 0, false
    
        for _, v in pairs(currentPath:GetWaypoints()) do
            if not _G.OngoingPath then
                print("Pathfinding stopped.")
                return false
            end
    
            if v.Action == Enum.PathWaypointAction.Jump and not jumpDebounce then
                jumpDebounce = true
                task.spawn(function()
                    hum:ChangeState(Enum.HumanoidStateType.Jumping)
                    task.wait(0.7)
                    jumpDebounce = false
                end)
            end
    
            local part = Instance.new("Part")
            part.Shape = "Ball"
            part.Material = "Neon"
            part.Size = Vector3.new(0.6, 0.6, 0.6)
            part.Position = v.Position + Vector3.new(0, 6, 0)
            part.Anchored = true
            part.CanCollide = false
            part.Parent = game.Workspace
    
            local oldpos = HRP.Position
            local updatedelay = false
    
            if lastupdate == nil then
                lastupdate = tick()
            else
                if (tick() - lastupdate) >= 2 then
                    lastupdate = tick()
                    oldhumanpos = HRP.Position
                end
            end
    
            if NotMoving and lastbroken and TimesBroken >= 3 then
                useOldMethod = true
            end
    
            if useOldMethod then
                if autosleepwalk == false then
                    game.Debris:AddItem(part, 0.01)
                    return
                end
                shared.AllowSprinting = true
                useOldMethod = true
                hum:MoveTo(v.Position)
                hum.MoveToFinished:Wait()
                game.Debris:AddItem(part, 0.01)
            else
                repeat
                    task.wait()
                    if autosleepwalk == false then
                        game.Debris:AddItem(part, 0.01)
                        return
                    end
                    _G.currentPoint = v.Position
                    if verifiedMoving then
                        shared.AllowSprinting = true
                    end
    
                    if
                        (HRP.Position - v.Position).Magnitude > 5
                        and (HRP.Position - part.Position).Magnitude > 4
                    then
                        if oldpos ~= HRP.Position and not lastbroken and not updatedelay then
                            task.spawn(function()
                                updatedelay = true
                                oldpos = HRP.Position
                                task.delay(1, function()
                                    updatedelay = false
                                end)
                            end)
                        elseif oldpos == HRP.Position and not lastbroken then
                            oldpos = HRP.Position
                            lastbroken = true
                            verifiedMoving = false
                            NotMoving = true
                            break
                        elseif oldpos == HRP.Position and lastbroken and not LBinit then
                            LBinit = true
                            task.spawn(function()
                                shared.AllowSprinting = false
                                task.wait(1)
                                if oldpos == HRP.Position and not jumpDebounce then
                                    if TimesBroken <= 0 then
                                        jumpDebounce = true
                                        task.spawn(function()
                                            hum:ChangeState(Enum.HumanoidStateType.Jumping)
                                            task.wait(0.7)
                                            currentPath:ComputeAsync(HRP.Position, point.Position)
                                            jumpDebounce = false
                                        end)
                                    end
                                end
    
                                oldpos = HRP.Position
                                lastbroken = false
                                LBinit = false
                                TimesBroken = TimesBroken + 1
                            end)
                        end
                    elseif oldhumanpos ~= nil then
                        if (HRP.Position - oldhumanpos).Magnitude <= 0.05 and not jumpDebounce then
                            jumpDebounce = true
                            task.spawn(function()
                                hum:ChangeState(Enum.HumanoidStateType.Jumping)
                                task.wait(0.7)
                                currentPath:ComputeAsync(HRP.Position, point.Position)
                                jumpDebounce = false
                            end)
                            oldhumanpos = nil
                            NotMoving = true
                            break
                        end
                    end
                    if (HRP.Position - oldpos).Magnitude > 1 then
                        verifiedMoving = true
                    end
                until (HRP.Position - v.Position).Magnitude < PointRangeTilNext
                    or (HRP.Position - part.Position).Magnitude < 5
                    or _G.OngoingPath ~= true
                    or autosleepwalk == false
                game.Debris:AddItem(part, 0.01)
            end
        end
    
        _G.OngoingPath = false
        print("Pathfinding completed successfully.")
        return true
    end
    
    local function ASworkaround()
        local newSequence
    
        for _, v in pairs(AutoSleepPaths) do
            local InsidePos = v["Sequence"][1]
            local MinimumDist = v["IsInsideDist"]
            local IsCorrectPlace = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - InsidePos.Position).Magnitude
                <= MinimumDist
    
            if IsCorrectPlace then
                newSequence = v["Sequence"]
                break
            end
        end
    
        if not newSequence then
            print("No valid sequence found for ASworkaround.")
            return false
        end
    
        autosleepwalk = true
    
        for i, v in pairs(newSequence) do
            local result = sleepWalk(v.Position)
            if result ~= true then
                print("Failed at step ", i)
                autosleepwalk = false
                return false
            else
                print("Completed Step ", i)
            end
        end
    
        print("ASworkaround completed successfully.")
        return true
    end

    function foodWalk(point)
        task.spawn(function()
            shared.AllowSprinting = false
            while task.wait(0.1) and (getgenv().food.AutoBuyFood and getgenv().food.BuyingFood) do
                pcall(function()
                    local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack:FindFirstChild("LocalS"))
                    local StamPercent = (
                        game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                    local LowStam = ministam
    
                    if isrunning == false and StamPercent >= 100 and shared.AllowSprinting then
                        actionscript.runPrompt()
                        isrunning = true
                        task.wait(1)
                    elseif isrunning == true and shared.AllowSprinting then
                        repeat StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value/ game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                            task.wait()
                        until StamPercent <= LowStam
                            or StamPercent == 100
                            or autosleepwalk == false
                            or shared.AllowSprinting == false
    
                        actionscript.stopSprint()
                        isrunning = false
                    elseif isrunning == true and shared.AllowSprinting == false then
                        actionscript.stopSprint()
                        isrunning = false
                    end
                end)
            end
    
            shared.AllowSprinting = false
        end)
    
        local plr = game.Players.LocalPlayer
        local char = plr.Character or plr.CharacterAdded:Wait()
        local hum = char:WaitForChild("Humanoid")
        local PFS = game:GetService("PathfindingService")
        local HRP = char:WaitForChild("HumanoidRootPart")
    
        local currentPath = PFS:CreatePath()
        currentPath:ComputeAsync(HRP.Position - Vector3.new(0, HRP.Position.Y/0.75, 0), point)
    
        print("[PATH STATUS] - ", currentPath.Status.Name)

        if currentPath.Status ~= Enum.PathStatus.Success then
            print("Failed to find path, retrying with point position...")
            return false
        end
    
        print("Path found successfully.")
        _G.OngoingPath = true
    
        task.spawn(function()
            while _G.OngoingPath and getgenv().food.AutoBuyFood do task.wait()
                local succ, err = pcall(function()
                    if _G.currentPoint ~= nil and (HRP.Position - _G.currentPoint).Magnitude > 5 then
                        hum.WalkToPoint = _G.currentPoint
                    end
                end)
                if not succ then warn("[FOOD WALK] - ", err) end
            end
        end)
    
        local lastbroken, LBinit, NotMoving = false, false, false
        local oldhumanpos, lastupdate = nil, nil
        local jumpDebounce = false
        local useOldMethod, TimesBroken, verifiedMoving = false, 0, false
    
        for _, v in pairs(currentPath:GetWaypoints()) do
            if not _G.OngoingPath then
                print("Pathfinding stopped.")
                return false
            end
    
            if v.Action == Enum.PathWaypointAction.Jump and not jumpDebounce then
                jumpDebounce = true
                task.spawn(function()
                    hum:ChangeState(Enum.HumanoidStateType.Jumping)
                    task.wait(0.7)
                    jumpDebounce = false
                end)
            end
    
            local part = Instance.new("Part")
            part.Shape = "Ball"
            part.Material = "Neon"
            part.Size = Vector3.new(0.6, 0.6, 0.6)
            part.Position = v.Position + Vector3.new(0, 6, 0)
            part.Anchored = true
            part.CanCollide = false
            part.Parent = game.Workspace
    
            local oldpos = HRP.Position
            local updatedelay = false
    
            if lastupdate == nil then
                lastupdate = tick()
            else
                if (tick() - lastupdate) >= 2 then
                    lastupdate = tick()
                    oldhumanpos = HRP.Position
                end
            end
    
            if NotMoving and lastbroken and TimesBroken >= 3 then
                useOldMethod = true
            end

            if useOldMethod then
                if getgenv().food.AutoBuyFood == false then
                    game.Debris:AddItem(part, 0.01)
                    return
                end
                shared.AllowSprinting = true
                useOldMethod = true
                local startTime = os.clock()
                hum:MoveTo(v.Position)
                hum.MoveToFinished:Wait()
                game.Debris:AddItem(part, 0.01)
            else
                repeat
                    task.wait()
                    if getgenv().food.AutoBuyFood == false then
                        game.Debris:AddItem(part, 0.01)
                        return
                    end
                    _G.currentPoint = v.Position
                    if verifiedMoving then
                        shared.AllowSprinting = true
                    end
    
                    if
                        (HRP.Position - v.Position).Magnitude > 5
                        and (HRP.Position - part.Position).Magnitude > 4
                    then
                        if oldpos ~= HRP.Position and not lastbroken and not updatedelay then
                            task.spawn(function()
                                updatedelay = true
                                oldpos = HRP.Position
                                task.delay(1, function()
                                    updatedelay = false
                                end)
                            end)
                        elseif oldpos == HRP.Position and not lastbroken then
                            oldpos = HRP.Position
                            lastbroken = true
                            verifiedMoving = false
                            NotMoving = true
                            break
                        elseif oldpos == HRP.Position and lastbroken and not LBinit then
                            LBinit = true
                            task.spawn(function()
                                shared.AllowSprinting = false
                                task.wait(1)
                                if oldpos == HRP.Position and not jumpDebounce then
                                    if TimesBroken <= 0 then
                                        jumpDebounce = true
                                        task.spawn(function()
                                            hum:ChangeState(Enum.HumanoidStateType.Jumping)
                                            task.wait(0.7)
                                            jumpDebounce = false
                                        end)
                                    end
                                end
    
                                oldpos = HRP.Position
                                lastbroken = false
                                LBinit = false
                                TimesBroken = TimesBroken + 1
                            end)
                        end
                    elseif oldhumanpos ~= nil then
                        if (HRP.Position - oldhumanpos).Magnitude <= 0.05 and not jumpDebounce then
                            jumpDebounce = true
                            task.spawn(function()
                                hum:ChangeState(Enum.HumanoidStateType.Jumping)
                                task.wait(0.7)
                                jumpDebounce = false
                            end)
                            oldhumanpos = nil
                            NotMoving = true
                            break
                        end
                    end
                    if (HRP.Position - oldpos).Magnitude > 1 then
                        verifiedMoving = true
                    end
                until (HRP.Position - v.Position).Magnitude < PointRangeTilNext
                    or (HRP.Position - part.Position).Magnitude < 5
                    or _G.OngoingPath ~= true
                    or (getgenv().food.AutoBuyFood == false)
                game.Debris:AddItem(part, 0.01)
            end
        end
    
        _G.OngoingPath = false
        print("Pathfinding completed successfully.")
        return true
    end

    function foodWalkKungFu(point)
        task.spawn(function()
            shared.AllowSprinting = false
            while task.wait(0.1) and getgenv().food.AutoBuyFoodKungFu and getgenv().food.BuyingFood do
                pcall(function()
                    local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack:FindFirstChild("LocalS"))
                    local StamPercent = (
                        game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                    local LowStam = ministam
    
                    if isrunning == false and StamPercent >= 100 and shared.AllowSprinting then
                        actionscript.runPrompt()
                        isrunning = true
                        task.wait(1)
                    elseif isrunning == true and shared.AllowSprinting then
                        repeat StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value/ game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                            task.wait()
                        until StamPercent <= LowStam
                            or StamPercent == 100
                            or autosleepwalk == false
                            or shared.AllowSprinting == false
    
                        actionscript.stopSprint()
                        isrunning = false
                    elseif isrunning == true and shared.AllowSprinting == false then
                        actionscript.stopSprint()
                        isrunning = false
                    end
                end)
            end
    
            shared.AllowSprinting = false
        end)
    
        local plr = game.Players.LocalPlayer
        local char = plr.Character or plr.CharacterAdded:Wait()
        local hum = char:WaitForChild("Humanoid")
        local PFS = game:GetService("PathfindingService")
        local HRP = char:WaitForChild("HumanoidRootPart")
    
        local currentPath = PFS:CreatePath()
        currentPath:ComputeAsync(HRP.Position - Vector3.new(0, HRP.Position.Y/0.75, 0), point)
    
        print("[PATH STATUS] - ", currentPath.Status.Name)

        if currentPath.Status ~= Enum.PathStatus.Success then
            print("Failed to find path, retrying with point position...")
            return false
        end
    
        print("Path found successfully.")
        _G.OngoingPath = true
    
        task.spawn(function()
            while _G.OngoingPath and getgenv().food.AutoBuyFoodKungFu do task.wait()
                local succ, err = pcall(function()
                    if _G.currentPoint ~= nil and (HRP.Position - _G.currentPoint).Magnitude > 5 then
                        hum.WalkToPoint = _G.currentPoint
                    end
                end)
                if not succ then warn("[FOOD WALK] - ", err) end
            end
        end)
    
        local lastbroken, LBinit, NotMoving = false, false, false
        local oldhumanpos, lastupdate = nil, nil
        local jumpDebounce = false
        local useOldMethod, TimesBroken, verifiedMoving = false, 0, false
    
        for _, v in pairs(currentPath:GetWaypoints()) do
            if not _G.OngoingPath then
                print("Pathfinding stopped.")
                return false
            end
    
            if v.Action == Enum.PathWaypointAction.Jump and not jumpDebounce then
                jumpDebounce = true
                task.spawn(function()
                    hum:ChangeState(Enum.HumanoidStateType.Jumping)
                    task.wait(0.7)
                    jumpDebounce = false
                end)
            end
    
            local part = Instance.new("Part")
            part.Shape = "Ball"
            part.Material = "Neon"
            part.Size = Vector3.new(0.6, 0.6, 0.6)
            part.Position = v.Position + Vector3.new(0, 6, 0)
            part.Anchored = true
            part.CanCollide = false
            part.Parent = game.Workspace
    
            local oldpos = HRP.Position
            local updatedelay = false
    
            if lastupdate == nil then
                lastupdate = tick()
            else
                if (tick() - lastupdate) >= 2 then
                    lastupdate = tick()
                    oldhumanpos = HRP.Position
                end
            end
    
            if NotMoving and lastbroken and TimesBroken >= 3 then
                useOldMethod = true
            end

            if useOldMethod then
                if getgenv().food.AutoBuyFoodKungFu == false then
                    game.Debris:AddItem(part, 0.01)
                    return
                end
                shared.AllowSprinting = true
                useOldMethod = true
                local startTime = os.clock()
                hum:MoveTo(v.Position)
                hum.MoveToFinished:Wait()
                game.Debris:AddItem(part, 0.01)
            else
                repeat
                    task.wait()
                    if getgenv().food.AutoBuyFoodKungFu == false then
                        game.Debris:AddItem(part, 0.01)
                        return
                    end
                    _G.currentPoint = v.Position
                    if verifiedMoving then
                        shared.AllowSprinting = true
                    end
    
                    if
                        (HRP.Position - v.Position).Magnitude > 5
                        and (HRP.Position - part.Position).Magnitude > 4
                    then
                        if oldpos ~= HRP.Position and not lastbroken and not updatedelay then
                            task.spawn(function()
                                updatedelay = true
                                oldpos = HRP.Position
                                task.delay(1, function()
                                    updatedelay = false
                                end)
                            end)
                        elseif oldpos == HRP.Position and not lastbroken then
                            oldpos = HRP.Position
                            lastbroken = true
                            verifiedMoving = false
                            NotMoving = true
                            break
                        elseif oldpos == HRP.Position and lastbroken and not LBinit then
                            LBinit = true
                            task.spawn(function()
                                shared.AllowSprinting = false
                                task.wait(1)
                                if oldpos == HRP.Position and not jumpDebounce then
                                    if TimesBroken <= 0 then
                                        jumpDebounce = true
                                        task.spawn(function()
                                            hum:ChangeState(Enum.HumanoidStateType.Jumping)
                                            task.wait(0.7)
                                            jumpDebounce = false
                                        end)
                                    end
                                end
    
                                oldpos = HRP.Position
                                lastbroken = false
                                LBinit = false
                                TimesBroken = TimesBroken + 1
                            end)
                        end
                    elseif oldhumanpos ~= nil then
                        if (HRP.Position - oldhumanpos).Magnitude <= 0.05 and not jumpDebounce then
                            jumpDebounce = true
                            task.spawn(function()
                                hum:ChangeState(Enum.HumanoidStateType.Jumping)
                                task.wait(0.7)
                                jumpDebounce = false
                            end)
                            oldhumanpos = nil
                            NotMoving = true
                            break
                        end
                    end
                    if (HRP.Position - oldpos).Magnitude > 1 then
                        verifiedMoving = true
                    end
                until (HRP.Position - v.Position).Magnitude < PointRangeTilNext
                    or (HRP.Position - part.Position).Magnitude < 5
                    or _G.OngoingPath ~= true
                    or (getgenv().food.AutoBuyFoodKungFu == false)
                game.Debris:AddItem(part, 0.01)
            end
        end
    
        _G.OngoingPath = false
        print("Pathfinding completed successfully.")
        return true
    end

    function checkForPath(targetPosition)
        local LocalPlayer = player
        local Humanoid = LocalPlayer.Character:WaitForChild("Humanoid")
        local HumanoidRootPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart")

        local path = PFS:CreatePath({
            AgentRadius = 2,
            AgentHeight = 5,
            AgentCanJump = true,
            AgentJumpHeight = 7,
            AgentMaxSlope = 45
        })

        path:ComputeAsync(HumanoidRootPart.Position - Vector3.new(0, HumanoidRootPart.Position.Y/0.75, 0), targetPosition)

        if path.Status ~= Enum.PathStatus.Success then return "No path"
        else return "Success" end
    end

    function moveToPoint(targetPosition)
        local LocalPlayer = player
        local Humanoid = LocalPlayer.Character:WaitForChild("Humanoid")
        local HumanoidRootPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart")

        local path = PFS:CreatePath({
            AgentRadius = 2,
            AgentHeight = 5,
            AgentCanJump = true,
            AgentJumpHeight = 7,
            AgentMaxSlope = 45
        })

        path:ComputeAsync(HumanoidRootPart.Position - Vector3.new(0, HumanoidRootPart.Position.Y/0.75, 0), targetPosition)

        if path.Status ~= Enum.PathStatus.Success then return "No path" end

        local waypoints = path:GetWaypoints()
        for _, waypoint in ipairs(waypoints) do
            if not strikepower then
                break
            end
            if waypoint.Action == Enum.PathWaypointAction.Jump then
                Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
            
            Humanoid:MoveTo(waypoint.Position)
            local prevPosition = HumanoidRootPart.Position
            local startTime = os.clock()

            while not Humanoid.MoveToFinished:Wait(0.5) do
                if not strikepower then
                    break
                end
                local distanceMoved = (HumanoidRootPart.Position - prevPosition).Magnitude

                if distanceMoved < 3 then
                    if os.clock() - startTime > 3 then
                        task.wait(0.02)
                        Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                        startTime = tick()
                    end
                else
                    startTime = tick() 
                end

                prevPosition = HumanoidRootPart.Position
            end
        end
    end

    local function maintenancechecks()
        if AutoStop then
            local Fatigue = tonumber(game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.BodyFatigue.Text:split(" ")[3]:split("%")[1])
            if Fatigue >= FatigueToStop then
                disableAllTraining()
                if macroruin then
                    webhook("Macro Notifier", "Max Fatigue Reached!")
                end
    
                if LogOnFatigued then
                    if macroruin then
                        webhook("Macro Notifier", "Logging. Fatigue full")
                        task.wait(3)
                    end
    
                    repeat
                        task.wait()
                    until not game.Players.LocalPlayer.PlayerGui.MainGui.Utility.CombatTag.Visible
                    game:shutdown()
                    return
                elseif autosleepRes or autosleepLog then
                    autosleepwalk = true
                    local GUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("TreadmillMachineGUI")
                        or game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("BarbellMachineGUI")
                        or game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("SquatMachineGUI")
    
                    if game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool") then
                        game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                    end
    
                    if GUI then
                        task.spawn(function()
                            SimulateClick(GUI.Frame.Close, "Function")
                        end)
                        task.wait(1)
                    end
    
                    local sleepWalkBack = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
    
                    if macroruin then
                        webhook("Auto Sleep", "Starting Pathfinding to a bed")
                        task.wait()
                    end
    
                    _G.currentPoint = nil
                    _G.OngoingPath = false

                    local UnoccupiedBed = GetBed()

                    local function fallbackAndRetry()
                        local fallbackPosition = CFrame.new(-780, 47, -300)
                        sleepWalk(fallbackPosition)
                        return GetBed()
                    end
                
                    local UnoccupiedBed = GetBed()
                
                    while not (UnoccupiedBed and UnoccupiedBed:FindFirstChild("Matress")) do
                        UnoccupiedBed = fallbackAndRetry()
                    end
                
                    local Mattress = UnoccupiedBed.Matress
                    local PlayerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
                    local IsCloseEnough = (Mattress.Position - PlayerPosition).Magnitude <= (UnoccupiedBed.ClickDetector.MaxActivationDistance or 0)
                
                    if not IsCloseEnough then
                        local sleepResult = sleepWalk(Mattress.CFrame)
                        
                        if sleepResult ~= true then
                            local workaroundResult = ASworkaround()
                
                            if workaroundResult ~= true then
                                UnoccupiedBed = fallbackAndRetry()
                
                                if UnoccupiedBed and UnoccupiedBed:FindFirstChild("Matress") then
                                    sleepResult = sleepWalk(UnoccupiedBed.Matress.CFrame)
                                end
                
                                if sleepResult ~= true then
                                    return webhook("Auto Sleep", "Sleep walk workaround was unsuccessful")
                                end
                            else
                                UnoccupiedBed = GetBed()
                
                                if UnoccupiedBed and UnoccupiedBed:FindFirstChild("Matress") then
                                    sleepResult = sleepWalk(UnoccupiedBed.Matress.CFrame)
                                end
                
                                if sleepResult ~= true then
                                    return webhook("Auto Sleep", "Sleep walk workaround was unsuccessful")
                                end
                            end
                        end
                    end

                    autosleepwalk = false
    
                    repeat task.wait()
                        if UnoccupiedBed then
                        if UnoccupiedBed:FindFirstChild("OccupiedBy") == nil then
                            fireclickdetector(UnoccupiedBed.ClickDetector)
                            task.wait(1)
                            if UnoccupiedBed:FindFirstChild("OccupiedBy") then
                                if UnoccupiedBed:FindFirstChild("OccupiedBy").Value == game.Players.LocalPlayer.Character then
                                    break
                                end
                            end
                        else
                            if UnoccupiedBed.OccupiedBy.Value ~= game.Players.LocalPlayer.Character then
                                UnoccupiedBed = GetBed()
                            else
                                break
                            end
    
                            local sleepResult = sleepWalk(UnoccupiedBed:FindFirstChild("Blanket").CFrame)
    
                            if sleepResult ~= true then
                                return webhook("Auto Sleep", "Sleep walk was unsuccessful")
                            end
                        end
                    end
                    until IsSleeping()
    
                    if macroruin then
                        webhook("Auto Sleep", "Successfully reached bed, sleeping fatigue off")
                        task.wait()
                    end
    
                    repeat
                        local Fatigue = tonumber(game.Players.LocalPlayer.PlayerGui.MainGui.Utility.BodyFatigue.Text:split(" ")[3]:split("%")[1])
                        task.wait()
                    until Fatigue <= 0
    
                    if autosleepLog then
                        if macroruin then
                            webhook("Auto Sleep", "Logging. Fatigue 0%")
                            task.wait(3)
                        end
    
                        repeat task.wait() until not game.Players.LocalPlayer.PlayerGui.MainGui.Utility.CombatTag.Visible
                        game:shutdown()
                        return
                    elseif autosleepRes then
                        fireclickdetector(UnoccupiedBed.ClickDetector)
                        task.wait(1)
    
                        autosleepwalk = true
    
                        if macroruin then
                            webhook("Auto Sleep", "0% Fatigue! heading towards last spot")
                        end
    
                        if not UnoccupiedBed.Parent.Name:find("Apartment") then
                            local trainWalk = sleepWalk(sleepWalkBack)
    
                            if trainWalk ~= true then
                                autosleepwalk = false
                                return webhook("Auto Sleep", "Pathfinding after sleeping was unsuccessful")
                            end
    
                            local distancefromSpot = (sleepWalkBack.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
    
                            if distancefromSpot <= 1 then
                                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(sleepWalkBack.Position)
                                task.wait(0.3)
                                game:GetService("TweenService"):Create(game.Players.LocalPlayer.Character.HumanoidRootPart, TweenInfo.new(0.3), { ["CFrame"] = sleepWalkBack }):Play()
                                task.wait(0.3)
                            elseif distancefromSpot <= 10 and distancefromSpot > 1 then
                                game.Players.LocalPlayer.Character.Humanoid:MoveTo(sleepWalkBack.Position)
                                game.Players.LocalPlayer.Character.Humanoid.MoveToFinished:Wait()
                                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(sleepWalkBack.Position)
                                task.wait(0.3)
                                game:GetService("TweenService"):Create(game.Players.LocalPlayer.Character.HumanoidRootPart, TweenInfo.new(0.3), { ["CFrame"] = sleepWalkBack }):Play()
                                task.wait(0.3)
                            end
                        end
    
                        autosleepwalk = false
                        restoreTraining()
                        if macroruin then
                            webhook("Macro Notifier", "Successfully resumed training after sleeping")
                        end
                    end
                end
            end
        end

        if LogOnNotEnoughMoney and machines then
            local Money = tonumber(game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.Money.Text:split("$")[2])

            if Money ~= nil then
                if Money < 65 then
                    if macroruin then
                        webhook("Macro Notifier", "Not Enough Money to Continue Machines")
                        task.wait(3)
                    end

                    repeat task.wait()
                    until game.Players.LocalPlayer.PlayerGui.MainGui.Utility.CombatTag.Visible == false
                    game:shutdown()
                end
            end
        end

        if autoeat then
            local hungerpercent = (game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.StomachBar.BarF.Bar.AbsoluteSize.X / game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.StomachBar.BarF.AbsoluteSize.X) * 100
            local foodfound = false

            if hungerpercent <= EatAt then
                for i, v in pairs(MOfoods) do
                    local food = game.Players.LocalPlayer.Backpack:FindFirstChild(v) or 
                                 game.Players.LocalPlayer.Character:FindFirstChild(v)
        
                    if food then
                        foodfound = true
                        local function AutoEat()
                            if stopAEinCombat and game.Players.LocalPlayer.PlayerGui.MainGui.Utility.CombatTag.Visible then
                                return
                            end
        
                            while hungerpercent < FillUp and autoeat do
                                hungerpercent = (game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.StomachBar.BarF.Bar.AbsoluteSize.X / game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.StomachBar.BarF.AbsoluteSize.X) * 100
                                food = game.Players.LocalPlayer.Backpack:FindFirstChild(v) or 
                                       game.Players.LocalPlayer.Character:FindFirstChild(v)
                                if not food then
                                    break
                                end
        
                                if food.Parent ~= game.Players.LocalPlayer.Character then
                                    game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                                    task.wait(0.1)
                                    game.Players.LocalPlayer.Character.Humanoid:EquipTool(food)
                                    task.wait(0.1)
                                end
        
                                food:Activate()
                                task.wait(3) 
                            end
        
                            game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                        end
        
                        if hungerpercent < FillUp and autoeat then
                            AutoEat()
                        end
                        break
                    end
                end
        
                if not foodfound then
                    if NoFoodNotify then
                        webhook("Macro Notifier", "You ran out of food.")
                        disableAllTraining()
                    end
        
                    if LogOnNoFood then
                        if NoFoodNotify then
                            webhook("No Food Notifier", "You ran out of food. Logging.")
                            task.wait(3)
                        end
        
                        repeat
                            task.wait()
                        until not game.Players.LocalPlayer.PlayerGui.MainGui.Utility.CombatTag.Visible
                        game:shutdown()
                    end
                end
            end
        end
        
        if autosupplement then
            if selectedsupplement ~= nil then
                if game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.VisualFrame:FindFirstChild(selectedsupplement)== nil and game.Players.LocalPlayer.Backpack:FindFirstChild(selectedsupplement)
                then
                    local oldQuantity = nil
                    game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                    task.wait(0.1)
                    game.Players.LocalPlayer.Character.Humanoid:EquipTool(game.Players.LocalPlayer.Backpack:FindFirstChild(selectedsupplement))
                    task.wait(0.1)
                    oldQuantity = game.Players.LocalPlayer.Character:FindFirstChild(selectedsupplement).Quantity.Value
                    game.Players.LocalPlayer.Character:FindFirstChild(selectedsupplement):Activate()
                    task.wait(0.1)
                    repeat
                        local took = false

                        if game.Players.LocalPlayer.Character:FindFirstChild(selectedsupplement) == nil then
                            took = true
                        else
                            if
                                game.Players.LocalPlayer.Character:FindFirstChild(selectedsupplement).Quantity.Value ~= oldQuantity
                            then
                                took = true
                            end
                        end
                        task.wait()
                    until took == true
                    game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                    task.wait(0.1)
                end
            end
        end

        if autosupplement2 then
            pcall(function()
            if game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.VisualFrame:FindFirstChild(selectedsupplement) == nil 
                and game.Players.LocalPlayer.Backpack:FindFirstChild(selectedsupplement) then
                game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                task.wait(0.1)
                game.Players.LocalPlayer.Character.Humanoid:EquipTool(game.Players.LocalPlayer.Backpack:FindFirstChild(selectedsupplement))
                task.wait(0.1)
                local oldQuantity = game.Players.LocalPlayer.Character:FindFirstChild(selectedsupplement).Quantity.Value
                repeat
                    local took = false
                    if game.Players.LocalPlayer.Character:FindFirstChild(selectedsupplement) == nil or game.Players.LocalPlayer.Character:FindFirstChild(selectedsupplement).Quantity.Value ~= oldQuantity - DrinkAmm then
                    game.Players.LocalPlayer.Character:FindFirstChild(selectedsupplement):Activate()
                    end
                    if game.Players.LocalPlayer.Character:FindFirstChild(selectedsupplement) == nil or game.Players.LocalPlayer.Character:FindFirstChild(selectedsupplement).Quantity.Value == oldQuantity - DrinkAmm then
                        took = true
                    end
                    task.wait()
                until took == true
                game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                task.wait(0.1)
            end
        end)
        end
        

    end
    
    local function automacrosprint()
        if CurrentRegening then
            shared.AllowSprinting = false
            VIM:SendKeyEvent(true, "W", false, game)
            task.wait(0.5)
        else
            shared.AllowSprinting = true
            VIM:SendKeyEvent(true, "W", false, game)
            task.wait(0.5)
        end
    end

    local function panicdash()
        if not panicdashdebounce then
            panicdashdebounce = true
            local haha = { "W", "A", "S", "D" }
            local randomdirection = haha[math.random(1, #haha)]

            VIM:SendKeyEvent(false, "W", false, game)
            task.wait()
            VIM:SendKeyEvent(true, randomdirection, false, game)
            task.wait(0.02)
            VIM:SendKeyEvent(true, "Q", false, game)
            task.wait()
            VIM:SendKeyEvent(false, "Q", false, game)
            task.wait(0.02)
            VIM:SendKeyEvent(false, randomdirection, false, game)
            task.wait()
            VIM:SendKeyEvent(true, "W", false, game)
            task.wait()
            task.delay(panicdashdelay, function()
                panicdashdebounce = false
            end)
            if CurrentRegening == false then
                automacrosprint()
            end
        end
    end

    local function StaminaCheck(lowstam, stamto)
        if lowstam == nil then
            lowstam = ministam
        end
        local function GetStamina()
            return (game.Players.LocalPlayer.Character.CurrentStamina.Value/ game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
        end

        local function LowStamina()
            if stamto == nil then
                if regenstamina then
                    stamto = regentoamt
                else
                    stamto = ministam
                end
            end

            if CurrentRegening == false then
                task.spawn(function()
                    repeat
                        task.wait()
                        CurrentRegening = true
                    until GetStamina() >= stamto
                    CurrentRegening = false
                end)
            end
        end

        if GetStamina() <= lowstam and CurrentRegening == false then
            LowStamina()
        end
    end

    local function panicstamcheck()
        local function GetStamina()
            return (game.Players.LocalPlayer.Character.CurrentStamina.Value/ game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
        end

        local function LowStamina()
            if CurrentRegening == false then
                task.spawn(function()
                    repeat
                        task.wait()
                        shared.AllowSprinting = false
                        CurrentRegening = true
                    until GetStamina() >= regentoamt
                    CurrentRegening = false
                end)
            end
        end

        if GetStamina() <= ministam then
            LowStamina()
        end
    end

    local ESPObjects = {}

    local function removeESP(plrobj)
        if ESPObjects[plrobj] then
            if ESPObjects[plrobj].NameLabel then ESPObjects[plrobj].NameLabel:Remove() end
            if ESPObjects[plrobj].HPLabel then ESPObjects[plrobj].HPLabel:Remove() end
            if ESPObjects[plrobj].StyleLabel then ESPObjects[plrobj].StyleLabel:Remove() end
            if ESPObjects[plrobj].Highlight then ESPObjects[plrobj].Highlight:Destroy() end
            ESPObjects[plrobj] = nil
        end
    end
    
    local function esp(plrobj)
        if plrobj == game.Players.LocalPlayer or ESP == false then
            return
        end

        removeESP(plrobj)
    
        local NameLabel = Drawing.new("Text")
        NameLabel.Visible = false
        NameLabel.Center = true
        NameLabel.Outline = true
        NameLabel.Font = 1
        NameLabel.Color = Color3.fromRGB(0, 255, 0)
        NameLabel.Size = 14
    
        local HPLabel = Drawing.new("Text")
        HPLabel.Visible = false
        HPLabel.Center = true
        HPLabel.Outline = true
        HPLabel.Font = 1
        HPLabel.Color = Color3.fromRGB(255, 0, 0)
        HPLabel.Size = 14
    
        local StyleLabel = Drawing.new("Text")
        StyleLabel.Visible = false
        StyleLabel.Center = true
        StyleLabel.Outline = true
        StyleLabel.Font = 1
        StyleLabel.Color = Color3.fromRGB(255, 255, 255)
        StyleLabel.Size = 14
    
        local style
    
        local function FindStyle()
            pcall(function()
                local tool = plrobj.Character:FindFirstChildOfClass("Tool")
                if tool and tool:FindFirstChild("Style") then
                    style = tool.Name
                else
                    for _, v in pairs(plrobj.Backpack:GetChildren()) do
                        if v:FindFirstChild("Style") then
                            style = v.Name
                            return
                        end
                    end
                    style = "None"
                end
            end)
        end
    
        FindStyle()
    
        local highlight
        if highlightplayers then
            highlight = Instance.new("Highlight")
            highlight.Adornee = plrobj.Character
            highlight.FillColor = Color3.fromRGB(128, 0, 255)
            highlight.FillTransparency = 0.5
            highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
            highlight.OutlineTransparency = 0
            highlight.Parent = plrobj.Character
        end
    
        ESPObjects[plrobj] = {
            NameLabel = NameLabel,
            HPLabel = HPLabel,
            StyleLabel = StyleLabel,
            Highlight = highlight
        }
    
        local renderstepped
        renderstepped = rs.RenderStepped:Connect(function()
            pcall(function()
                local distance = (plrobj.Character.HumanoidRootPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
    
                if not plrobj.Character or not plrobj.Character:FindFirstChild("Head") or distance > ESPDistance or not game.Players:FindFirstChild(plrobj.Name) or ESP == false then
                    removeESP(plrobj)
                    renderstepped:Disconnect()
                    return
                end
    
                local plr_pos, plr_onscreen = camera:WorldToViewportPoint(plrobj.Character.Head.Position)
    
                if plr_onscreen then
                    local ToolEquipped = plrobj.Character:FindFirstChildOfClass("Tool") or { Name = "nil" }
    
                    NameLabel.Position = Vector2.new(plr_pos.X, plr_pos.Y - 50)
                    NameLabel.Text = "[" .. plrobj.Name .. "][" .. round(distance) .. "]"
                    NameLabel.Visible = true
    
                    HPLabel.Position = Vector2.new(plr_pos.X, plr_pos.Y - 35)
                    HPLabel.Text = "[" .. round((plrobj.Character.Humanoid.Health / plrobj.Character.Humanoid.MaxHealth) * 100) .. "% HP]"
                    HPLabel.Visible = true
    
                    StyleLabel.Position = Vector2.new(plr_pos.X, plr_pos.Y - 20)
                    StyleLabel.Text = "[" .. style .. "][" .. ToolEquipped.Name .. "]"
                    StyleLabel.Visible = true
                else
                    NameLabel.Visible = false
                    HPLabel.Visible = false
                    StyleLabel.Visible = false
                end
            end)
        end)
    end

    local function Candyesp()
        for i, v in pairs(workspace.Event:GetDescendants()) do
            if v:IsA("MeshPart") and v.Parent.Name == "" and v.Parent:IsA("Model") and v.Parent:FindFirstChildOfClass("ClickDetector") and not v.Parent:FindFirstChildOfClass("Humanoid") then
                local NameLabel = Drawing.new("Text")
                NameLabel.Visible = false
                NameLabel.Center = true
                NameLabel.Outline = true
                NameLabel.Font = 1
                NameLabel.Color = Color3.fromRGB(255, 99, 71)
                NameLabel.Size = 14
    
                local renderstepped
                renderstepped = game:GetService("RunService").RenderStepped:Connect(function()
                    pcall(function()
                        if not espToggles[v] then
                            NameLabel:Remove()
                            renderstepped:Disconnect()
                            return
                        end
    
                        local camera = game.Workspace.CurrentCamera
                        local distance = (v.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
    
                        if not v or not v.Parent or distance > ESPDistance then
                            NameLabel:Remove()
                            renderstepped:Disconnect()
                            espToggles[v] = nil
                            return
                        end
    
                        local obj_pos, obj_onscreen = camera:WorldToViewportPoint(v.Position)
    
                        if obj_onscreen then
                            NameLabel.Position = Vector2.new(obj_pos.X, obj_pos.Y - 50)
                            NameLabel.Text = "[Halloween Candy][" .. math.floor(distance) .. "]"
                            NameLabel.Visible = true
                        else
                            NameLabel.Visible = false
                        end
                    end)
                end)
    
                espToggles[v] = {
                    label = NameLabel,
                    connection = renderstepped
                }
            end
        end
    end
    
    local function RemoveAllESP()
        for _, espData in pairs(espToggles) do
            if espData.label then
                espData.label:Remove()
            end
            if espData.connection then
                espData.connection:Disconnect()
            end
        end
        espToggles = {}
    end
    
    function GetPunchingBag()
        local bag = nil
        local spbestdistance = math.huge

        local baginstances = {
            workspace.Map["Bag Wrestling"],
            workspace.Map,
            workspace["Kung Fu Dojo"].Bag,
            workspace.Map.Model,
            workspace["Organisation Building"],
            workspace["Judo Dojo"].bags,
            workspace:GetChildren()[37],
            workspace,
        }
    
        for _, instance in pairs(baginstances) do
            --print(instance:GetFullName())
            for _, v in pairs(instance:GetChildren()) do
                --print(v:GetFullName())
                if v:FindFirstChild("bag") and v.bag:IsA("MeshPart") then
                    if v:FindFirstChild("PunchingBag") then
                        v = v.PunchingBag
                    end
                    local distance = (v.bag.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if distance <= 100 and (not spbestdistance or distance < spbestdistance) then
                        spbestdistance = distance
                        bag = v
                    end
                end
            end
        end
        return bag
    end
    
    local function GetStyle()
        local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
        if tool ~= nil then
            if tool:FindFirstChild("Style") then
                return tool
            end
        end

        for i, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
            if v:FindFirstChild("Style") then
                return v
            end
        end

        return nil
    end

    local function GetClosestRoadwork()
        local rw, bestdistance = nil, nil

        for i, v in pairs(workspace.Map:GetChildren()) do
            if v.Name:find("Roadwork") then
                local Closest = 100
                local distance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Head.Position).Magnitude

                if bestdistance then
                    if distance < bestdistance then
                        bestdistance = distance
                        rw = v
                    end
                else
                    bestdistance = distance
                    rw = v
                end
            end
        end

        return rw
    end

    local function GetDuraBuy()
        local bestdistance, durabuy = nil, nil
        local durainstances = {
            workspace.Map,
            workspace.kUREtRAINER,
        }
    
        for _, instance in pairs(durainstances) do
            for i, v in pairs(instance:GetChildren()) do
                if v.Name == "Durability Training: $140" then
                    local clickDetector = v:FindFirstChildOfClass("ClickDetector")
                    if clickDetector then
                        local distance = (v.PrimaryPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                        local MaxActivationDist = clickDetector.MaxActivationDistance
    
                        if bestdistance then
                            if distance < MaxActivationDist then
                                bestdistance = MaxActivationDist
                                durabuy = v
                            elseif distance < bestdistance then
                                bestdistance = distance
                                durabuy = v
                            end
                        else
                            bestdistance = distance
                        end
                    end
                end
            end
        end
    
        return durabuy
    end

    --[[

    local function duraturn(main, support)
        if not durability then return end
    
        local function waitForHealth(character)
            repeat task.wait() until character.Humanoid.Health >= character.Humanoid.MaxHealth
            task.wait(0.5)
        end
    
        local function equipTool(tool)
            if tool and tool.Parent ~= game.Players.LocalPlayer.Character then
                game.Players.LocalPlayer.Character.Humanoid:EquipTool(tool)
                task.wait(0.2)
            end
        end
    
        local function activateTool(tool, waitTime)
            if tool.Parent == game.Players.LocalPlayer.Character then
                tool:Activate()
                task.wait(waitTime or 0.2)
            end
        end
    
        if main.Character.Humanoid.Health < main.Character.Humanoid.MaxHealth then
            waitForHealth(main.Character)
        end
    
        local distance = (main.Character.HumanoidRootPart.Position - support.Character.HumanoidRootPart.Position).Magnitude
        if not GetDuraBuy() and not SkillXP then return end
    
        if distance > 17 and distance <= 200 then
            repeat
                distance = (main.Character.HumanoidRootPart.Position - support.Character.HumanoidRootPart.Position).Magnitude
                task.wait()
            until distance <= 17
            task.wait(0.5)
        end
    
        local mychar = game.Players.LocalPlayer.Character
        if support.Character.Name == mychar.Name and durability then
            if not SkillXP then
                repeat task.wait() until main.Character:FindFirstChild("DuraTrain") or not durability
    
                local combatTool = GetStyle() or game.Players.LocalPlayer.Backpack:FindFirstChild(DuraTool)
                equipTool(combatTool)
    
                repeat
                    local healthpercent = (main.Character.Humanoid.Health / main.Character.Humanoid.MaxHealth) * 100
                    if healthpercent > stopAtHP and main.Character:FindFirstChild("DuraTrain") then
                        if RhythmToggle then ChargeRhythm(combatTool) end
                        activateTool(combatTool, 0.05)
                    end
                    task.wait()
                until healthpercent <= stopAtHP or not main.Character:FindFirstChild("DuraTrain")
    
                task.wait(0.1)
                game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                task.wait(0.9)
            else
                repeat
                    local SkillTool, SkillHotbar = GetSkill()
                    local healthpercent = (main.Character.Humanoid.Health / main.Character.Humanoid.MaxHealth) * 100
    
                    if healthpercent > stopAtHP and SkillTool and SkillHotbar and not SkillHotbar.CD.Visible then
                        equipTool(SkillTool)
                        activateTool(SkillTool, 1)
                        repeat task.wait() until SkillHotbar.CD.Visible
                    end
                    task.wait()
                until healthpercent <= stopAtHP or not durability or not SkillXP
    
                task.wait(0.1)
                game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                task.wait(0.9)
            end
        elseif main.Character.Name == mychar.Name and durability then
            if not SkillXP then
                local Dura = GetDuraBuy()
                local BeforeDuraDonePos = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
    
                if main.Character.Humanoid.Health < main.Character.Humanoid.MaxHealth then
                    waitForHealth(main.Character)
                end
    
                local durTool = game.Players.LocalPlayer.Backpack:FindFirstChild("Durability Training")
                if not durTool then
                    repeat
                        fireclickdetector(Dura.ClickDetector)
                        task.wait(1)
                    until game.Players.LocalPlayer.Backpack:FindFirstChild("Durability Training")
                    durTool = game.Players.LocalPlayer.Backpack:FindFirstChild("Durability Training")
                end
                equipTool(durTool)
                activateTool(durTool)
    
                repeat
                    local healthpercent = (game.Players.LocalPlayer.Character.Humanoid.Health / game.Players.LocalPlayer.Character.Humanoid.MaxHealth) * 100
                    if healthpercent <= stopAtHP then
                        activateTool(durTool, 1)
                    end
                    task.wait()
                until healthpercent <= stopAtHP or not durability
    
                task.wait(1)
                if AutoWalkAfterPushedBack then
                    local distance = (BeforeDuraDonePos - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if distance > 2 then
                        game.Players.LocalPlayer.Character.Humanoid:MoveTo(BeforeDuraDonePos)
                        game.Players.LocalPlayer.Character.Humanoid.MoveToFinished:Wait()
                    end
                end
            else
                repeat
                    local healthpercent = (game.Players.LocalPlayer.Character.Humanoid.Health / game.Players.LocalPlayer.Character.Humanoid.MaxHealth) * 100
                    task.wait()
                until healthpercent <= stopAtHP or not durability or not SkillXP
            end
        end
    end
    --]]


        timeout = 5000
        local function checkFailsafe()
            if lastActionTime and timeout then
                if os.clock() - lastActionTime > timeout then
                    print("resetting")
                    disableAllTraining()
                    task.wait(0.5)
                    restoreTraining()
                    lastActionTime = os.clock()
                end
            else
                lastActionTime = os.clock()
            end
        end
    
        function duraturn(main, support)
            if not durability then return end
            --print("[Main] - ", main.Name, " ", " [Support] - ", support.Name)
            -- Helper functions
            local function waitForHealth(characterForHp)
                repeat task.wait() until characterForHp.Humanoid.Health >= characterForHp.Humanoid.MaxHealth
                task.wait(0.5)
            end
        
            local function equipTool(tool)
                if tool and tool.Parent ~= game.Players.LocalPlayer.Character then
                    game.Players.LocalPlayer.Character.Humanoid:EquipTool(tool)
                    task.wait(0.2)
                end
            end
        
            local function activateTool(tool, waitTime)
                if tool.Parent == game.Players.LocalPlayer.Character then
                    tool:Activate()
                    task.wait(waitTime or 0.2)
                end
            end
        
            local function resetPosition(beforePos)
                if AutoWalkAfterPushedBack then
                    game.Players.LocalPlayer.Character.Humanoid:MoveTo(beforePos)
                    game.Players.LocalPlayer.Character.Humanoid.MoveToFinished:Wait()
                end
            end
        
            --print("hp check in duraturn next")
            -- Ensure main player's health is full
            if main.Character.Humanoid.Health < main.Character.Humanoid.MaxHealth then
                waitForHealth(main.Character)
            end
            --print("passed hp check in duraturn")
        
            -- Ensure players are within range
            local distance = (main.Character.HumanoidRootPart.Position - support.Character.HumanoidRootPart.Position).Magnitude
            if not GetDuraBuy() and not SkillXP then return end
            --print("passed GetDuraBuy")
            
            if distance > 17 and distance <= 200 then
                repeat
                    distance = (main.Character.HumanoidRootPart.Position - support.Character.HumanoidRootPart.Position).Magnitude
                    task.wait()
                    checkFailsafe()
                until distance <= 17
                task.wait(0.5)
                --resetTimer()
            end

            --print("passed dist check")
            -- Main character's tool logic
            local mychar = game.Players.LocalPlayer.Character
            --print("My char.Name .. ", mychar.Name)
            if support.Character.Name == mychar.Name and durability then
                --print("Support - ", mychar.Name)
                if not SkillXP then
                    repeat
                        task.wait()
                        checkFailsafe()
                    until main.Character:FindFirstChild("DuraTrain") or not durability
                    --print("[Support] Main has dura in inv")
                    local combatTool = GetStyle() or game.Players.LocalPlayer.Backpack:FindFirstChild(DuraTool)
                    --print("[Support] Combat tool name - ", combatTool.Name)
                    equipTool(combatTool)
        
                    repeat
                        local healthpercent = (main.Character.Humanoid.Health / main.Character.Humanoid.MaxHealth) * 100
                        if healthpercent > stopAtHP and main.Character:FindFirstChild("DuraTrain") then
                            if RhythmToggle then ChargeRhythm(combatTool) end
                            activateTool(combatTool, 0.05)
                        end
                        task.wait()
                        checkFailsafe()
                    until healthpercent <= stopAtHP or not main.Character:FindFirstChild("DuraTrain") or not main.Character:FindFirstChild("Durability Training")
        
                    task.wait(0.1)
                    game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                    task.wait(0.9)
                    --resetTimer()
                else
                    repeat
                        local SkillTool, SkillHotbar = GetSkill()
                        local healthpercent = (main.Character.Humanoid.Health / main.Character.Humanoid.MaxHealth) * 100
        
                        if healthpercent > stopAtHP and SkillTool and SkillHotbar and not SkillHotbar.CD.Visible then
                            equipTool(SkillTool)
                            activateTool(SkillTool, 1)
                            repeat
                                task.wait()
                                checkFailsafe()
                            until SkillHotbar.CD.Visible
                        end
                        task.wait()
                    until healthpercent <= stopAtHP or not durability or not SkillXP or not main.Character:FindFirstChild("Durability Training")
        
                    task.wait(0.1)
                    game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                    task.wait(0.9)
                    --resetTimer()
                end
            elseif main.Character.Name == mychar.Name and durability then
                --print("Main - ", main.Character.Name)
                if not SkillXP then
                    local Dura = GetDuraBuy()
                    local BeforeDuraDonePos = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
                    --print("[Main] Dura - ", Dura)
                    if main.Character.Humanoid.Health < main.Character.Humanoid.MaxHealth then
                        waitForHealth(main.Character)
                    end
                    --print("[Main] Passed Health Check")
                    local durTool = game.Players.LocalPlayer.Backpack:FindFirstChild("Durability Training")
                    if not durTool then
                        repeat
                            fireclickdetector(Dura.ClickDetector)
                            task.wait(1)
                            checkFailsafe()
                        until game.Players.LocalPlayer.Backpack:FindFirstChild("Durability Training")
                        durTool = game.Players.LocalPlayer.Backpack:FindFirstChild("Durability Training")
                        --resetTimer()
                    end
        
                    equipTool(durTool)
                    activateTool(durTool)
                    
                    local healthpercent = nil
                    repeat
                        healthpercent = (game.Players.LocalPlayer.Character.Humanoid.Health / game.Players.LocalPlayer.Character.Humanoid.MaxHealth) * 100
                        if healthpercent <= stopAtHP then
                            activateTool(durTool, 1)
                            --print("[Main] Deactivating Dura")
                        end
                        print("[Main] checking hp")
                        task.wait()
                        checkFailsafe()
                    until healthpercent <= stopAtHP or not durability or not game.Players.LocalPlayer.Character:FindFirstChild("Durability Training")
                    
                    resetPosition(BeforeDuraDonePos)
                    task.wait(1)
                    --print("[Main] Finished Dura")
                else
                    repeat
                        local healthpercent = (game.Players.LocalPlayer.Character.Humanoid.Health / game.Players.LocalPlayer.Character.Humanoid.MaxHealth) * 100
                        task.wait()
                        checkFailsafe()
                    until healthpercent <= stopAtHP or not durability or not SkillXP or not game.Players.LocalPlayer.Character:FindFirstChild("Durability Training")
                    resetPosition(BeforeDuraDonePos)
                end
            end
        end
        
    
    local function GetSSBuy()
        local bestdistance, ss = nil, nil
        local ssinstances = {workspace.Map, workspace.kUREtRAINER}
        local player = game.Players.LocalPlayer
        local originalPosition = player.Character.HumanoidRootPart.Position

        maintenancechecks()
        for _, instance in ipairs(ssinstances) do
            for _, v in ipairs(instance:GetChildren()) do
                if v.Name:find("Strike Speed Training") or v:FindFirstChild("Strike Speed Training: $180") then
                    local target = v:FindFirstChild("Strike Speed Training: $180") or v
                    local distance = (player.Character.HumanoidRootPart.Position - target.Head.Position).Magnitude
                    local MaxActivationDist = target.ClickDetector.MaxActivationDistance

                    if distance <= MaxActivationDist then
                        if not bestdistance or bestdistance > distance then
                            bestdistance = distance 
                            ss = target
                        end
                    elseif distance > MaxActivationDist then
                        if distance < buydistances then
                            moveto, ss = true, target
                        end
                    end
                end
            end
        end

        return ss
    end
    
    function updateCombo(v)
        if not strikespeed then
            if comboconnectionss then
                comboconnectionss:Disconnect()
            end
            return
        end
        if v.Name == "Attacking" then
            currentcombo = v.Value
        end
    end

    function manageCombatTool()
        local combatTool = GetStyle()

        if combatTool and combatTool.Parent ~= game.Players.LocalPlayer.Character then
            game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
            task.wait(0.3)
            game.Players.LocalPlayer.Character.Humanoid:EquipTool(combatTool)
            task.wait(0.1)
        end
    end

    function handleStrikeSpeed(ssbuy, originalPosition)
        local succ, err = pcall(function()
            local strikeSpeedTool = player.Backpack:FindFirstChild("Strike Speed Training") or player.Character:FindFirstChild("Strike Speed Training")
            local ssbuy = GetSSBuy()
            --print(ssbuy)
            local bag  = GetPunchingBag()

            print("!", bag, ssbuy)

            local OriginalPos = character.PrimaryPart.Position
            local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack:FindFirstChild("LocalS"))

            if strikeSpeedTool then
                player.Character.Humanoid:EquipTool(strikeSpeedTool)
                strikeSpeedTool:Activate()
            else
                if moveto then
                    --print("Ad")
                    donebuying = false
                    actionscript.runPrompt()
                    moveToPoint(ssbuy.Head.Position)
                    task.wait()
                    actionscript.stopSprint()
                    fireclickdetector(ssbuy.ClickDetector)
                    task.wait()
                    task.wait(0.6)
                    local bagPos = bag.bag.Position
                    moveToPoint(bagPos)
                    local myVector = character.HumanoidRootPart.Position
                    if myVector and bagPos then
                        local distance = (myVector - bagPos).Magnitude
                        --print("distance " .. distance)
                        if distance > 4 then
                            local direction = (bagPos - myVector).Unit
                            if direction then
                                local targetPosition = myVector + direction * (distance - 5) 
                                character.Humanoid:MoveTo(targetPosition)
                                character.Humanoid.MoveToFinished:Wait()
                                --print("Finished moving")
                            end
                        end
                        --print("AAAA")
                    elseif distance < 1 then
                        local direction = (bagPos - myVector).Unit
                        --print("direciton2 " .. direction)
                        if direction then
                            local targetPosition = myVector + direction * (distance + 2) 
                            character.Humanoid:MoveTo(targetPosition)
                            character.Humanoid.MoveToFinished:Wait()
                        end
                    end
                    --print("AA")
                    task.wait(0.2)
                    local targetPosition = bag.bag.Position
                    local humanoidRootPart = game.Players.LocalPlayer.Character.HumanoidRootPart
                    local lookAtRotation = CFrame.lookAt(humanoidRootPart.Position, Vector3.new(targetPosition.X, humanoidRootPart.Position.Y, targetPosition.Z))
                    game:GetService("TweenService"):Create(humanoidRootPart,TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut),{ CFrame = CFrame.new(humanoidRootPart.Position, humanoidRootPart.Position + lookAtRotation.LookVector) }):Play()
                    --player.PivotTo(lookAtRotation)
                    --print("AAasdsadsa")
                    strikeSpeedTool = player.Backpack:FindFirstChild("Strike Speed Training")
                    moveto, donebuying = false, true
                    if strikeSpeedTool and donebuying then
                        player.Character.Humanoid:EquipTool(strikeSpeedTool)
                    end
                else
                    donebuying = false
                    maintenancechecks()
                    player.Character.Humanoid:UnequipTools()
                    task.wait(0.1)
                    repeat task.wait(1)
                        fireclickdetector(ssbuy.ClickDetector)
                    until player.Backpack:FindFirstChild("Strike Speed Training")
                    task.wait(0.5)
                    strikeSpeedTool = player.Backpack:FindFirstChild("Strike Speed Training")
                    repeat task.wait(0.5)
                        player.Character.Humanoid:EquipTool(strikeSpeedTool)
                    until player.Character:FindFirstChild("Strike Speed Training")
                    donebuying = true
                end
            end
        
            task.wait(0.2)
            repeat
                task.wait(0.5)
                if not player.PlayerGui:FindFirstChild("SpeedTraining") and player.Character:FindFirstChild("Strike Speed Training") and donebuying then
                    strikeSpeedTool:Activate()
                end
            until player.PlayerGui:FindFirstChild("SpeedTraining")
        end)
        if not succ then warn(err) end
    end

    function combatLoop()
        --if strikespeed then
            local bag = GetPunchingBag()
            local ssbuy = GetSSBuy()
            local combatTool = GetStyle()

            print(ssbuy)

            if bag and ssbuy then
                if not game.Players.LocalPlayer.PlayerGui:FindFirstChild("SpeedTraining") then
                    handleStrikeSpeed(ssbuy, game.Players.LocalPlayer.Character.HumanoidRootPart.Position)
                end
            end

            manageCombatTool()

            local m2nextturn = false
            repeat
                if RhythmToggle then
                    ChargeRhythm(combatTool)
                end

                if game.Players.LocalPlayer.PlayerGui:FindFirstChild("SpeedTraining") then
                    if game.Players.LocalPlayer.PlayerGui.SpeedTraining.CanHit.Value and combatTool.Parent == game.Players.LocalPlayer.Character then
                        if not m2nextturn then
                            repeat
                                combatTool:Activate()
                                task.wait(m1speedslider)
                            until game.Players.LocalPlayer.PlayerGui.SpeedTraining.CanHit.Value == false or combatTool.Parent == game.Players.LocalPlayer.Backpack or not strikespeed
                        else
                            if ssuseM2 then
                                repeat
                                    local successm2 = currentcombo == 5
                                    if successm2 then break end
                                    local VIM = game:GetService("VirtualInputManager")
                                    VIM:SendMouseButtonEvent(0, 500, 1, true, game, 1)
                                    wait(0.1)
                                    VIM:SendMouseButtonEvent(0, 500, 1, false, game, 1)
                                    wait(0.5)
                                until successm2 or combatTool.Parent == game.Players.LocalPlayer.Backpack or not strikespeed
                            end
                            m2nextturn = false
                        end

                        local Jaja = tick()
                        repeat
                            task.wait()
                            if currentcombo == 4 and ssuseM2 then
                                m2nextturn = true
                            end
                        until not game.Players.LocalPlayer.PlayerGui.SpeedTraining.CanHit.Value or (tick() - Jaja) >= 0.5

                        if currentcombo == 4 and not m2nextturn and ssuseM2 then
                            m2nextturn = true
                        end
                    end
                    task.wait()
                end
            until not game.Players.LocalPlayer.PlayerGui:FindFirstChild("SpeedTraining") or not strikespeed
        --end
    end
    
    function debuffCheck()
        if game.Players.LocalPlayer.Character.Ragdolled.Value == true then
            return false
        end

        return true
    end

    spectatingPlr = player
    function initSpectate()
        for i,v in pairs(player.PlayerGui.PlayerList.Main.SF.Holder:GetChildren()) do
            if v:IsA("ImageButton") then
                v.MouseButton1Click:Connect(function()
                    local plrs = {}
                    for i,v in pairs(game:service"Players":GetPlayers()) do
                        plrs[v.Name] = v
                    end
                    local plrToSpec = plrs[v.Name]
                    if spectatingPlr and plrToSpec ~= spectatingPlr then
                        if plrToSpec and plrToSpec.Character then
                            spectatingPlr = plrToSpec
                            setCameraSubject(plrToSpec.Character)
                        end
                    elseif spectatingPlr and plrToSpec == spectatingPlr then
                        if player.Character then
                            spectatingPlr = player
                            setCameraSubject(player.Character)
                        end
                    end
                end)
            end
        end
    end
    initSpectate()

    main:AddLabel("Pushup/Squat auto train lowest mini stam is 15")

    main:AddToggle({
        Name = "Auto Train",
        Default = false,
        Save = false,
        Flag = "autotrain",
        Callback = function(Value)
            autotrain = Value
        end
    })

    coroutine.wrap(function()
        while task.wait() do
            if autotrain then
                StaminaCheck()
                maintenancechecks()
                pcall(function()
                    if traintype ~= nil and trainspeed ~= nil then
                        maintenancechecks()
                        if traintype ~= "Stamina" then
                            if game.Players.LocalPlayer.Character:FindFirstChild(traintype) and not CurrentRegening then
                                if trainspeed == "Slow" and not isrunning and debuffCheck() then
                                    local oldFatigue = tonumber(game.Players.LocalPlayer.PlayerGui.MainGui.Utility.BodyFatigue.Text:split(" ")[3]:split("%")[1])
                                    game.Players.LocalPlayer.Character[traintype]:Activate()
                                    local curtime = tick()
                                    repeat task.wait()
                                    until tonumber(game.Players.LocalPlayer.PlayerGui.MainGui.Utility.BodyFatigue.Text:split(" ")[3]:split("%")[1]) ~= oldFatigue or (tick() - curtime) >= 5 or not game.Players.LocalPlayer.Character:FindFirstChild(traintype)
                                elseif trainspeed == "Fast" and not isrunning and debuffCheck() then
                                    local StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                                    if StamPercent >= ministam or not autotrain then
                                    game.Players.LocalPlayer.Character[traintype]:Activate()
                                    end
                                end
                            elseif game.Players.LocalPlayer.Backpack:FindFirstChild(traintype) and not isrunning and not CurrentRegening then
                                local StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                                if StamPercent >= ministam or not autotrain then
                                game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                                task.wait(0.1)
                                game.Players.LocalPlayer.Character.Humanoid:EquipTool(game.Players.LocalPlayer.Backpack:FindFirstChild(traintype))
                                task.wait(0.1)
                            
                            end
                            end
                        elseif traintype == "Stamina" then
                            while task.wait(0.1) and autotrain and traintype == "Stamina" do
                                pcall(function()
                                    local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack.LocalS)
                                    local StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
    
                                    if not isrunning and StamPercent >= 100 and autotrain then
                                        actionscript.runPrompt()
                                        isrunning = true
                                        task.wait(1)
                                    elseif isrunning and autotrain then
                                        repeat
                                            StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                                            task.wait()
                                        until StamPercent <= ministam or not autotrain
    
                                        if StamPercent < 100 or not autotrain then
                                            actionscript.stopSprint()
                                            maintenancechecks()
                                        end
                                        isrunning = false
                                    end
                                end)
                            end
                        end
                    end
                end)
            end
        end
    end)()

    mainset:AddLabel("Auto Train Settings")

    mainset:AddToggle({
        Name = "Regen Stamina",
        Default = false,
        Save = true,
        Flag = "regenstamina",
        Callback = function(Value)
            regenstamina = Value
        end
    })

    mainset:AddSlider({
        Name = "Minimum Stamina %",
        Min = 0,
        Max = 100,
        Default = ministam,
        Color = Color3.fromRGB(251, 37, 96),
        ValueName = "Value",
        Save = true,
        Flag = "minstaminaperc",
        Callback = function(Value)
            ministam = Value
        end
    })

    mainset:AddSlider({
        Name = "Regen Stamina To %",
        Min = 0,
        Max = 100,
        Default = regentoamt,
        Color = Color3.fromRGB(251, 37, 96),
        ValueName = "Value",
        Save = true,
        Flag = "regenstamtoperc",
        Callback = function(Value)
            regentoamt = Value
        end
    })

    mainset:AddSlider({
        Name = "Stamina To Wait To After Set",
        Min = 0,
        Max = 100,
        Default = waittostamina,
        Color = Color3.fromRGB(251, 37, 96),
        ValueName = "Value",
        Save = true,
        Flag = "stamtowaitafterset",
        Callback = function(Value)
            waittostamina = Value
        end
    })

    main:AddDropdown({
        Name = "Train Type",
        Options = {"Push up", "Squat", "Stamina"},
        Save = true,
        Flag = "traintype",
        Callback = function(Value)
            traintype = Value
        end
    })

    main:AddDropdown({
        Name = "Train Speed",
        Options = {"Fast", "Slow"},
        Save = true,
        Flag = "trainspeed",
        Callback = function(Value)
            trainspeed = Value
        end
    })
    
    main:AddLabel("Striking Speed")
    
    function ssStart()
        while strikespeed do task.wait()
            local ssbuy = GetSSBuy()
    
            if ssbuy and strikespeed then
                combatLoop()
            end
        end
    end

    comboconnectionss = nil
    originalPositionSS = nil
    main:AddToggle({
        Name = "Strike Speed", 
        Default = false,
        Save = false,
        Flag = "strikespeed",
        Callback = function(Value)
            strikespeed = Value

            comboconnectionss = game.Players.LocalPlayer.Character.ChildAdded:Connect(function(v)
                if not strikespeed then
                    if comboconnectionss then
                        comboconnectionss:Disconnect()
                    end
                    return
                end
                if v.Name == "Attacking" and strikespeed then
                    currentcombo = v.Value
                end
            end)

            originalPositionSS = game.Players.LocalPlayer.Character.HumanoidRootPart.Position

            if strikespeed then
                ssStart()
            end
        end
    })


    mainset:AddLabel("Striking Speed Settings")

    mainset:AddToggle({
        Name = "SS Use M2",
        Default = false,
        Save = true,
        Flag = "ssusem2",
        Callback = function(Value)
            ssuseM2 = Value
        end
    })
    
    mainset:AddSlider({
        Name = "Striking Speed Purchase Distance",
        Min = 0,
        Max = 100,
        Default = buydistances,
        Color = Color3.fromRGB(220,20,60),
        Save = true,
        Flag = "sspurchasedist",
        Callback = function(Value)
            buydistances = Value
        end
    })
  
    mainset:AddSlider({
        Name = "Striking Speed Punch Speed",
        Min = 0,
        Max = 1,
        Default = m1speedslider,
        Color = Color3.fromRGB(220,20,60),
        Increment = 0.05,
        Save = true,
        Flag = "sspunchspeed",
        Callback = function(Value)
            m1speedslider = Value
        end
    })
    
    main:AddLabel("Striking Power")
    
    function startSp()
        while strikepower do task.wait()
            local bag = GetPunchingBag()
            local combatTool = GetStyle()

            if bag and strikepower then
                StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                maintenancechecks()

                if (bag:GetPivot().Position - player.Character.HumanoidRootPart.Position).Magnitude > mindistawayfrombag then
                    player.Character.Humanoid:MoveTo(bag:GetPivot().Position)
                end

                if not startPunching then
                    if StamPercent < RunToPercent then
                        repeat
                            StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                            task.wait()
                        until StamPercent >= RunToPercent or not strikepower

                        startPunching = true
                    elseif StamPercent > RunToPercent then
                        while task.wait(0.1) and strikepower and not startPunching do
                            if not strikepower then
                                return
                            end
                            pcall(function()
                                local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack.LocalS)
                                local StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100

                                if not isrunning and StamPercent > RunToPercent and strikepower then
                                    actionscript.runPrompt()
                                    isrunning = true
                                    task.wait(1)
                                elseif isrunning and strikepower then
                                    repeat
                                        StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                                        task.wait()
                                    until StamPercent <= RunToPercent or StamPercent == 100 or not strikepower

                                    if StamPercent <= RunToPercent and strikepower then
                                        actionscript.stopSprint()
                                        startPunching = true
                                    end
                                    isrunning = false
                                end
                            end)
                        end
                    end
                elseif startPunching and StamPercent > RunToPercent and StamPercent > PunchStartPercent and StamPercent > PunchEndPercent then
                    startPunching = false
                elseif startPunching and strikepower and combatTool then
                    repeat
                        local StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                        task.wait()
                    until StamPercent >= PunchStartPercent or not strikepower or PunchStartPercent < RunToPercent
                    
                    local targetPosition = bag.bag.Position
                    local humanoidRootPart = game.Players.LocalPlayer.Character.HumanoidRootPart
                    local lookAtRotation = CFrame.lookAt(humanoidRootPart.Position, Vector3.new(targetPosition.X, humanoidRootPart.Position.Y, targetPosition.Z))
                    game:GetService("TweenService"):Create(humanoidRootPart,TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut),{ CFrame = CFrame.new(humanoidRootPart.Position, humanoidRootPart.Position + lookAtRotation.LookVector) }):Play()

                    maintenancechecks()
                    if combatTool.Parent == game.Players.LocalPlayer.Backpack and strikepower and not reequipdebounce then
                        reequipdebounce = true
                        game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                        task.wait(0.1)
                        game.Players.LocalPlayer.Character.Humanoid:EquipTool(combatTool)
                        task.wait(0.1)
                        reequipdebounce = false
                    end

                    repeat
                        maintenancechecks()
                        task.wait()
                        if not strikepower  then
                            return
                        end
                        task.wait()
                        StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                        pcall(function()
                            if strikepower and RhythmToggle then
                                ChargeRhythm(combatTool)
                            end

                            if combatTool.Parent == game.Players.LocalPlayer.Character and not CurrentRegening then
                                repeat
                                    StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                                    if combatTool.Parent == game.Players.LocalPlayer.Character then
                                        combatTool:Activate()
                                    end
                                    task.wait()
                                until (currentcombo and currentcombo == 4)
                                    or combatTool.Parent == game.Players.LocalPlayer.Backpack
                                    or StamPercent <= PunchEndPercent
                                    or not startPunching
                                    or StamPercent >= 90
                                    or not strikepower

                                if currentcombo then
                                    if currentcombo == 4 and not m2already and StamPercent >= PunchEndPercent and spuseM2 then
                                        repeat
                                            local successm2 = false

                                            if game.Players.LocalPlayer.Character:FindFirstChild("Attacking") and game.Players.LocalPlayer.Character.Attacking.Value == 5 then
                                                successm2 = true
                                            end
                                            StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                                            local VIM = game:GetService("VirtualInputManager")
                                            VIM:SendMouseButtonEvent(0, 500, 1, true, game, 1)
                                            task.wait()
                                            VIM:SendMouseButtonEvent(0, 500, 1, false, game, 1)
                                            task.wait()
                                        until successm2 or not strikepower or StamPercent >= 90 or combatTool.Parent == game.Players.LocalPlayer.Backpack
                                        task.wait(0.1)
                                        m2already = true
                                    elseif currentcombo == 4 and m2already and StamPercent >= PunchEndPercent and spuseM2 then
                                        currentcombo = nil
                                        m2already = false
                                    end
                                end
                                task.wait()
                            end
                        end)
                    until not strikepower or StamPercent <= PunchEndPercent or StamPercent >= 90
                    startPunching = false
                end
            end
        end
    end

    comboconnectionSP = nil
    main:AddToggle({Name = "Strike Power",Default = false, Save = true, Flag = "strikepower", Callback = function(Value)
        strikepower = Value
        comboconnectionSP = game.Players.LocalPlayer.Character.ChildAdded:Connect(function(v)
            if not strikepower then
                if comboconnectionSP then
                    comboconnectionSP:Disconnect()
                end
                return
            end
            if v.Name == "Attacking" and strikepower then
                currentcombo = v.Value
            end
        end)

        startPunching = false
        reequipdebounce = false

        if strikepower then
            startSp()
        end
    end
    })


    main:AddSlider({
        Name = "Min Distance to be away from bag to auto move(SP)",
        Default = 4,
        Min = 1,
        Max = 50,
        Increment = 1,
        Color = Color3.fromRGB(117, 25, 255),
        ValueName = "Distance",
        Flag = "mindistawayfrombag",
        Save = true,
        Callback = function(value)
            getgenv().mindistawayfrombag = value
        end
    })
    
    mainset:AddLabel("Striking Power Settings")

    mainset:AddToggle({
        Name = "SP Use M2",
        Default = false,
        Save = true,
        Flag = "spusem2",
        Callback = function(Value)
            spuseM2 = Value
        end
    })

    mainset:AddSlider({
        Name = "SP Run to %",
        Min = 0,
        Max = 100,
        Default = RunToPercent,
        Color = Color3.fromRGB(117, 25, 255),
        ValueName = "Value",
        Save = true,
        Flag = "spruntoperc",
        Callback = function(Value)
            RunToPercent = Value
        end
    })

    mainset:AddSlider({
        Name = "SP Punch Start %",
        Min = 0,
        Max = 100,
        Default = PunchStartPercent,
        Color = Color3.fromRGB(117, 25, 255),
        ValueName = "Value",
        Save = true,
        Flag = "sppunchstartperc",
        Callback = function(Value)
            PunchStartPercent = Value
        end
    })

    mainset:AddSlider({
        Name = "SP Punch End %",
        Min = 0,
        Max = 100,
        Default = PunchEndPercent,
        Color = Color3.fromRGB(117, 25, 255),
        ValueName = "Value",
        Save = true,
        Flag = "sppunchendperc",
        Callback = function(Value)
            PunchEndPercent = Value
        end
    })

    mainset:AddLabel("Extra Settings")

    mainset:AddToggle({
        Name = "Use Rhythm on Trainings",
        Default = false,
        Save = true,
        Flag = "userhythmontrainings",
        Callback = function(Value)
            RhythmToggle = Value
        end
    })

    main:AddLabel("Machines")

    main:AddToggle({Name = "Machines",Default = false, Save = true, Flag = "machines", Callback = function(Value)
        machines = Value
    end
    })
    coroutine.wrap(function()
        while task.wait() do
            if machines then
                pcall(function()
                    if game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("TreadmillMachineGUI") and machines and machinetype ~= nil and treadselect ~= nil then
                        local GUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("TreadmillMachineGUI")
                        if GUI and machines then
                            if not GUI.Frame3.Visible then
                                StaminaCheck(waittostamina - 1, waittostamina)
                            end
                            if GUI.Frame.Visible and machines and CurrentRegening == false then
                                SimulateClick(GUI.Frame.StatPickF[treadselect], "Function")
                                task.wait(0.1)
                            elseif GUI.Frame2.Visible and machines and CurrentRegening == false then
                                local i = 5
                                repeat
                                    if not GUI.Frame2.Visible then
                                        break
                                    end
                                    SimulateClick(GUI.Frame2.ListF[tostring(i)], "Function")
                                    task.wait(0.1)
                                    i = i - 1
                                until i <= 0
                            elseif GUI.Frame3.Visible and machines and CurrentRegening == false then
                                if GUI.Frame3.Start.Visible and machines and CurrentRegening == false then
                                    task.spawn(function()
                                        SimulateClick(GUI.Frame3.Start, "Function")
                                    end)
                                    task.wait(0.1)
                                elseif not GUI.Frame3.Start.Visible and machines and CurrentRegening == false then
                                    StaminaCheck()
                                    if GUI.Frame3.TrainingF.ButtonTemplate.Visible and machines then
                                        if tostring(GUI.Frame3.TrainingF.ButtonTemplate.Input.TextColor3) == "1, 1, 1" and CurrentRegening == false then
                                            task.wait(0.07)
                                            VIM:SendKeyEvent(true, GUI.Frame3.TrainingF.ButtonTemplate.Input.Text, false, game)
                                            task.wait()
                                            VIM:SendKeyEvent(false, GUI.Frame3.TrainingF.ButtonTemplate.Input.Text, false, game)
                                            task.wait()
                                        end
                                    end
                                end
                            end
                        end
                    elseif game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("BarbellMachineGUI") or game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("SquatMachineGUI") and machinetype ~= nil then
                        local GUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("BarbellMachineGUI") or game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("SquatMachineGUI")
                        if GUI and machines then
                            if GUI.Frame.Visible then
                                StaminaCheck(99, 100)
                                task.wait()
                            end
                            if GUI.Frame.Visible and machines and CurrentRegening == false then
                                local i = 6
                                repeat
                                    if not GUI.Frame.Visible then
                                        break
                                    end
                                    SimulateClick(GUI.Frame.ListF["Barbell " .. tostring(i) .. " Weight"], "Function")
                                    task.wait(0.1)
                                    i = i - 1
                                until i <= 0
                            elseif GUI.Frame2.Visible and machines and CurrentRegening == false then
                                if GUI.Frame2.Start.Visible and machines and CurrentRegening == false then
                                    task.spawn(function()
                                        SimulateClick(GUI.Frame2.Start, "Function")
                                    end)
                                    task.wait(0.1)
                                elseif not GUI.Frame2.Start.Visible and machines and CurrentRegening == false then
                                    StaminaCheck()
                                    local Icon = GUI.Frame2.LiftingF:FindFirstChild("LiftIcon")
                                    if GUI.Frame2.LiftingF.Visible and machines then
                                        if Icon and CurrentRegening == false then
                                            task.wait(0.07)
                                            SimulateClick(Icon, "Function")
                                        end
                                    end
                                end
                            end
                        end
                    else
                        maintenancechecks()
                        if LastMachine ~= nil then
                            if (LastMachine.Base.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude <= LastMachine.ClickDetector.MaxActivationDistance and GetMachineType(LastMachine) == machinetype then
                                fireclickdetector(LastMachine.ClickDetector)
                                task.wait(0.5)
                            elseif GetMachineType(LastMachine) ~= machinetype then
                                LastMachine = nil
                            end
                        end
                        local MachineQuery = ClosestMachine()
                        if MachineQuery ~= nil and debuffCheck() and machinetype ~= nil then
                            LastMachine = MachineQuery
                            fireclickdetector(LastMachine.ClickDetector)
                            task.wait(0.5)
                        elseif MachineQuery == nil and debuffCheck() and machinetype ~= nil and WalkBackWhenFar and LastMachine ~= nil then
                            game.Players.LocalPlayer.Character.Humanoid:MoveTo(LastMachine.Base)
                            task.wait(2)
                        end
                    end
                end)
            end
            if not machines and LastMachine ~= nil then
                LastMachine = nil
            end
        end
    end)()

    

    main:AddDropdown({
        Name = "Machine",
        Options = {"Bench", "Squat", "Treadmill"},
        Save = true,
        Flag = "machine",
        Callback = function(Value)
            machinetype = Value
        end
    })

    main:AddDropdown({
        Name = "Treadmill Option",
        Options = {"Stamina", "RunningSpeed"},
        Save = true,
        Flag = "treadoption",
        Callback = function(Value)
            treadselect = Value
        end
    })

    mainset:AddToggle({
        Name = "Walk Back When Far",
        Default = false,
        Save = true,
        Flag = "walkbackwhenfar",
        Callback = function(Value)
            WalkBackWhenFar = Value
        end
    })

    mainset:AddToggle({
        Name = "Log When Money Out",
        Default = false,
        Save = true,
        Flag = "logwhenmoneyout",
        Callback = function(Value)
            LogOnNotEnoughMoney = Value
        end
    })

    main:AddLabel("Make sure both accs have same settings")
    main:AddLabel("You need 2 accounts that are using the script")
    
    doing_dura = false
    main:AddToggle({
        Name = "Durability",
        Default = false,
        Save = false,
        Flag = "autodura",
        Callback = function(Value)
            durability = Value
        end
    })
    
    coroutine.wrap(function()
        while task.wait() do
            if ft and st and durability then
                if game.Players.LocalPlayer.Name == ft or game.Players.LocalPlayer.Name == st then
                    local ftplr = game.Players:FindFirstChild(ft)
                    local stplr = game.Players:FindFirstChild(st)
                    
                    if ftplr and stplr and ftplr.Character and stplr.Character and not doing_dura then
                        print("[Player] ", game.Players.LocalPlayer.Name, " doing_dura - ", doing_dura)
                        local distanceBetweenPlrs = (ftplr.Character.HumanoidRootPart.Position - stplr.Character.HumanoidRootPart.Position).Magnitude
                        local duraCondition = GetDuraBuy() ~= nil or SkillXP
                        
                        if distanceBetweenPlrs <= 10 and duraCondition then
                            durainprogress = true
                            doing_dura = true
                            print("dura in progress")
                            
                            local function waitForFullHealth(plrForHpCheck)
                                repeat
                                    task.wait()
                                until plrForHpCheck.Character.Humanoid.Health >= plrForHpCheck.Character.Humanoid.MaxHealth or not durability
                            end

                            if taketurns then
                                
                                -- First player's turn
                                --print("First player turn")
                                waitForFullHealth(ftplr)
                                --print("first player full hp")
                                maintenancechecks()
                                --print("Passed maintenancechecks")
                                duraturn(ftplr, stplr)
                                

                                -- Second player's turn
                                --print("Second player turn")
                                waitForFullHealth(stplr)
                                --print("Second player full hp")
                                maintenancechecks()
                                --print("Passed maintenancechecks")
                                duraturn(stplr, ftplr)
                            else
                                --print("No turns")
                                -- Only first player's turn
                                waitForFullHealth(ftplr)
                                --print("[No turns] passed hp check")
                                maintenancechecks()
                                --print("[No turns] passed maintenance checks")
                                duraturn(ftplr, stplr)
                            end
                            doing_dura = false
                            --print("doing_dura ", doing_dura)
                            --durainprogress = false
                        end
                    end
                end
            end
        end
    end)()
    
    main:AddTextbox({
        Name = "First Turn",
        Default = "",
        Save = true,
        Flag = "firstturn",
        Callback = function(txt)
            ft = txt
        end
    })

    main:AddTextbox({
        Name = "Second Turn",
        Default = "",
        Save = true,
        Flag = "secondturn",
        Callback = function(txt)
            st = txt
        end
    })
    
    main:AddToggle({
        Name = "Take Turns",
        Default = false,
        Save = true,
        Flag = "taketurns",
        Callback = function(Value)
            taketurns = Value
        end
    })

    main:AddDropdown({
        Name = "DuraTool",
        Options = {"Metal Bat", "Revolver", "Default"},
        Save = true,
        Flag = "duratool",
        Callback = function(Value)
            DuraTool = Value
        end
    })

    mainset:AddLabel("Auto Walk After Being Pushed (Only for dura receiver)")

    mainset:AddToggle({
        Name = "Auto Walk After Pushed Back",
        Default = false,
        Save = true,
        Flag = "autowalkafterpushedback",
        Callback = function(Value)
            AutoWalkAfterPushedBack = Value
        end
    })

    main:AddSlider({
        Name = "Health % to Stop",
        Min = 0,
        Max = 100,
        Default = stopAtHP,
        Color = Color3.fromRGB(255, 17, 0),
        ValueName = "Value",
        Save = true,
        Flag = "healthperctostop",
        Callback = function(Value)
            stopAtHP = Value
        end
    })

    mainset:AddLabel("Makes dura farm a skill xp farm in sparring arenas")
    mainset:AddLabel("Have the skills on your hotbar for the farm")

    mainset:AddToggle({
        Name = "Skill XP mode",
        Default = false,
        Save = true,
        Flag = "skillxpmode",
        Callback = function(Value)
            SkillXP = Value
        end
    })


    notify:AddLabel("Staff (If u want it to disable put that on first!)")

    notify:AddToggle({
        Name = "Staff Notifier",
        Default = false,
        Save = true,
        Flag = "staffnotif",
        Callback = function(Value)
            staffnotifier = Value
            if staffnotifier then
                for _, v in pairs(game.Players:GetPlayers()) do
                    if staffnotifier then
                        Notifier(v)
                    end
                end
            end
        end
    })

    notify:AddToggle({
        Name = "Disable All When Staff Joins",
        Default = false,
        Save = true,
        Flag = "disableallwhenstaffjoins",
        Callback = function(Value)
            disableOnStaff = Value
        end
    })

    notify:AddLabel("Cop's")

    notify:AddToggle({
        Name = "Cop Notifier",
        Default = false,
        Save = true,
        Flag = "copnotifier",
        Callback = function(Value)
            copnotifier = Value
            if copnotifier then
                for _, v in pairs(game.Players:GetPlayers()) do
                    if copnotifier then
                        Notifier(v)
                    end
                end
            end
        end
    })

    notify:AddLabel("NPCS")

    notify:AddToggle({
        Name = "Flow NPC Notifier",
        Default = false,
        Save = true,
        Flag = "flownpcnotif",
        Callback = function(Value)
            flownotifier = Value
            if flownotifier then
                if game:GetService("Workspace"):FindFirstChild("XinFolder") then
                    local NPC = workspace:FindFirstChild("XinFolder") and workspace.XinFolder:FindFirstChild("Luke Xin")
                    if NPC and NPC:IsA("Model") then
                        Notifier()
                        local humanoidRootPart = NPC:FindFirstChild("HumanoidRootPart")
                        if humanoidRootPart then
                            local billboardGui = Instance.new("BillboardGui")
                            billboardGui.Parent = humanoidRootPart
                            billboardGui.Adornee = humanoidRootPart
                            billboardGui.Size = UDim2.new(0, 50, 0, 50)
                            billboardGui.StudsOffset = Vector3.new(0, 2, 0)
                            billboardGui.AlwaysOnTop = true
    
                            local imageLabel = Instance.new("ImageLabel")
                            imageLabel.Parent = billboardGui
                            imageLabel.Size = UDim2.new(1, 0, 1, 0)
                            imageLabel.Image = "rbxassetid://104832225542320"
                            imageLabel.BackgroundTransparency = 1
                        end
                    end
                end
                flowconnection = workspace.Live.ChildAdded:Connect(function()
                    if flownotifier then
                        local NPC = workspace:FindFirstChild("XinFolder") and workspace.XinFolder:FindFirstChild("Luke Xin")
                        if NPC and NPC:IsA("Model") then
                            local humanoidRootPart = NPC:FindFirstChild("HumanoidRootPart")
                            if humanoidRootPart then
                                local billboardGui = Instance.new("BillboardGui")
                                billboardGui.Parent = humanoidRootPart
                                billboardGui.Adornee = humanoidRootPart
                                billboardGui.Size = UDim2.new(0, 50, 0, 50)
                                billboardGui.StudsOffset = Vector3.new(0, 2, 0)
                                billboardGui.AlwaysOnTop = true
    
                                local imageLabel = Instance.new("ImageLabel")
                                imageLabel.Parent = billboardGui
                                imageLabel.Size = UDim2.new(1, 0, 1, 0)
                                imageLabel.Image = "rbxassetid://104832225542320"
                                imageLabel.BackgroundTransparency = 1
                            end
                        end
                    end
                end)
            else
                if flowconnection then
                    flowconnection:Disconnect()
                end
                local NPC = workspace:FindFirstChild("XinFolder") and workspace.XinFolder:FindFirstChild("Luke Xin")
                if NPC then
                    local humanoidRootPart = NPC:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        local billboardGui = humanoidRootPart:FindFirstChildOfClass("BillboardGui")
                        if billboardGui then
                            billboardGui:Destroy()
                        end
                    end
                end
            end
        end
    })
    
    notify:AddToggle({
        Name = "Street Fighter Notifier",
        Default = false,
        Save = true,
        Flag = "streetfighternotif",
        Callback = function(Value)
            sfnotifier = Value
            if sfnotifier then
                if game:GetService("Workspace"):FindFirstChild("AokiFolder") then
                    local NPC = workspace:FindFirstChild("AokiFolder") and workspace.AokiFolder:FindFirstChild("NPC")
                    if NPC and NPC:IsA("Model") then
                        Notifier()
                        local humanoidRootPart = NPC:FindFirstChild("HumanoidRootPart")
                        if humanoidRootPart then
                            local billboardGui = Instance.new("BillboardGui")
                            billboardGui.Parent = humanoidRootPart
                            billboardGui.Adornee = humanoidRootPart
                            billboardGui.Size = UDim2.new(0, 50, 0, 50)
                            billboardGui.StudsOffset = Vector3.new(0, 2, 0)
                            billboardGui.AlwaysOnTop = true
    
                            local imageLabel = Instance.new("ImageLabel")
                            imageLabel.Parent = billboardGui
                            imageLabel.Size = UDim2.new(1, 0, 1, 0)
                            imageLabel.Image = "rbxassetid://104832225542320"
                            imageLabel.BackgroundTransparency = 1
                        end
                    end
                end
                sfconnection = workspace.ChildAdded:Connect(function(child)
                    if sfnotifier then
                        if child.ClassName == "Folder" and child.Name == "AokiFolder" then
                            local NPC = workspace:FindFirstChild("AokiFolder") and workspace.AokiFolder:FindFirstChild("NPC")
                            if NPC and NPC:IsA("Model") then
                                local humanoidRootPart = NPC:FindFirstChild("HumanoidRootPart")
                                if humanoidRootPart then
                                    local billboardGui = Instance.new("BillboardGui")
                                    billboardGui.Parent = humanoidRootPart
                                    billboardGui.Adornee = humanoidRootPart
                                    billboardGui.Size = UDim2.new(0, 50, 0, 50)
                                    billboardGui.StudsOffset = Vector3.new(0, 2, 0)
                                    billboardGui.AlwaysOnTop = true
    
                                    local imageLabel = Instance.new("ImageLabel")
                                    imageLabel.Parent = billboardGui
                                    imageLabel.Size = UDim2.new(1, 0, 1, 0)
                                    imageLabel.Image = "rbxassetid://104832225542320"
                                    imageLabel.BackgroundTransparency = 1
                                end
                            end
                        end
                    end
                end)
            else
                if sfconnection then
                    sfconnection:Disconnect()
                end
                local NPC = workspace:FindFirstChild("AokiFolder") and workspace.AokiFolder:FindFirstChild("NPC")
                if NPC then
                    local humanoidRootPart = NPC:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        local billboardGui = humanoidRootPart:FindFirstChildOfClass("BillboardGui")
                        if billboardGui then
                            billboardGui:Destroy()
                        end
                    end
                end
            end
        end
    })
    
    notify:AddLabel("Macro Ruiner")

    notify:AddToggle({
        Name = "Macro Ruiner Notifier",
        Default = false,
        Save = true,
        Flag = "macroruinernotif",
        Callback = function(Value)
            macroruin = Value
            if macroruin then
                local connection
                connection = game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
                    if not macroruin then
                        connection:Disconnect()
                        return
                    end
                    if child.Name == "ErrorPrompt" and child:FindFirstChild("MessageArea") and child.MessageArea:FindFirstChild("ErrorFrame") then
                        task.wait(0.5)
                        webhook("Macro Ruin Notifier", "You were disconnected. Reason:\n" .. child.MessageArea.ErrorFrame.ErrorMessage.Text)
                    end
                end)
            end
    
            local sound
            local function stopSound()
                if sound and sound.IsPlaying then
                    sound:Stop()
                end
                UserSettings():GetService("UserGameSettings").MasterVolume = oldVolume or 0.5
            end
    
            while macroruin and task.wait() do
                if game.Players.LocalPlayer.PlayerGui.MainGui.Utility.CombatTag.Visible and not macroruindebounce and alreadynotifieduser ~= CurrentGanker and CurrentGanker then
                    macroruindebounce = true
                    alreadynotifieduser = CurrentGanker
                    if playmacroruinaudio then
                        if oldVolume == nil then
                            oldVolume = UserSettings():GetService("UserGameSettings").MasterVolume
                        end
                        local level = 10 / 10
                        UserSettings():GetService("UserGameSettings").MasterVolume = level
                        CurrentlyPlaying[#CurrentlyPlaying + 1] = playsound(gettinggankedsound)
                        game.StarterGui:SetCore("SendNotification", {
                            Title = "Macro Ganker!",
                            Text = "Getting Ganked By:".. CurrentGanker,
                            Duration = math.huge,
                            Button1 = "Stop niii!",
                            Callback = Bindable,
                        })
                    end
                    webhook("Macro Ruin Notifier", "You are getting macro ganked! Get your get back!\n" .. CurrentGanker)
                    task.wait(0.5)
                    macroruindebounce = false
                end
            end
        end
    }) 
    
    notify:AddToggle({
        Name = "Play Audio When Ganked",
        Default = false,
        Save = true,
        Flag = "playaudiowhenganked",
        Callback = function(Value)
            playmacroruinaudio = Value
        end
    })

    touchedConn = nil
    NotifyOnPush = false
    PosForPush = nil
    DistForPush = 3
    PushDebounce = false
    notify:AddToggle({
        Name = "Notify When Someone Pushes You",
        Default = false,
        Save = true,
        Flag = "notifywhenpushed",
        Callback = function(state)
            NotifyOnPush = state
            if not NotifyOnPush then
                if touchedConn then
                    touchedConn:Disconnect()
                    touchedConn = nil
                end
            else
                if not touchedConn then
                    if not player.Character then player.CharacterAdded:Wait() end
                    if not player.Character:FindFirstChild("HumanoidRootPart") then player.Character:WaitForChild("HumanoidRootPart") end
                    touchedConn = player.Character.HumanoidRootPart.Touched:Connect(function(hit)
                        if NotifyOnPush then
                            local otherPlayer = game:service"Players":GetPlayerFromCharacter(hit.Parent)
                            if PosForPush then 
                                if otherPlayer and (PosForPush - player.Character.HumanoidRootPart.Position).Magnitude >= DistForPush and not PushDebounce then
                                    PushDebounce = true
                                    webhook("Push Notifier", otherPlayer.Name .. " potentially pushed you by " .. tostring((PosForPush - player.Character.HumanoidRootPart.Position).Magnitude) .. " meters")
                                    task.wait(3)
                                    PushDebounce = false
                                end
                            else
                                OrionLib:MakeNotification({
                                    Name = "Push Notifier",
                                    Content = "Please Set Your Position First",
                                    Image = "rbxassetid://4483345998",
                                    Time = 5
                                })
                            end
                        end
                    end)
                end
            end
        end
    })
    notify:AddButton({
        Name = "Set Position for Push",
        Callback = function()
            pcall(function() PosForPush = player.Character.HumanoidRootPart.Position end)
            OrionLib:MakeNotification({
                Name = "Set Pos for Push",
                Content = "Set Position to " .. tostring(player.Character.HumanoidRootPart.Position),
                Image = "rbxassetid://4483345998",
                Time = 5
            })
        end
    })
    notify:AddSlider({
        Name = "Min Distance for Push Notify",
        Default = 3,
        Save = true,
        Flag = "mindistforpushnotif",
        Min = 1,
        Max = 15,
        Increment = 0.5,
        ValueName = "Distance",
        Color = Color3.fromRGB(246, 255, 0),
        Callback = function(value)
            DistForPush = value
        end
    })
    
    pcall(function()
        if writefile then
            if not OPsData then
                local defaultData = {"PlayerUserIdHere", "AnotherPlayerUserIdHere", "BeSureToAddCommaAfter"}
                writefile("MOoppositions.json", game:GetService("HttpService"):JSONEncode(defaultData))
            end
            pcall(function()
                OPsData = game:GetService("HttpService"):JSONDecode(readfile("MOoppositions.json"))
            end)
            notify:AddLabel("Go to your executor's folder to add ops")
            notify:AddLabel("Executor/workspace/MOoppositions.json")
            notify:AddToggle({
                Name = "Notify when OPs join",
                Default = false,
                Callback = function(Value)
                    OPSNotifier = Value
                    OPsData = game:GetService("HttpService"):JSONDecode(readfile("MOoppositions.json"))
                    for _, v in ipairs(game.Players:GetPlayers()) do
                        if table.find(OPsData, tostring(v.UserId)) then
                            if playopssound then
                                if oldVolume == nil then
                                    oldVolume = UserSettings():GetService("UserGameSettings").MasterVolume
                                end
                                local level = 10 / 10
                                UserSettings():GetService("UserGameSettings").MasterVolume = level
                                CurrentlyPlaying[#CurrentlyPlaying + 1] = playsound(opjoinedsound)
                                game.StarterGui:SetCore("SendNotification", {
                                    Title = "Ops Joined!",
                                    Text = "Op Joined:".. v.Name,
                                    Duration = math.huge,
                                    Button1 = v.Name .. " K Till My Bones Decay!",
                                    Callback = Bindable,
                                })
                            end
                            webhook("Opposition Detected", "DisplayName: " .. v.DisplayName .. "\nUsername: " .. v.Name .. "\nUserId: " .. tostring(v.UserId))
                        end
                    end
                    while OPSNotifier and task.wait() do
                        OPsData = game:GetService("HttpService"):JSONDecode(readfile("MOoppositions.json"))
                    end
                end
            })
        end
    end)

    notify:AddToggle({
        Name = "Play Audio When Ops Join",
        Default = false,
        Save = true,
        Flag = "playaudiowhenops",
        Callback = function(Value)
            playopssound = Value
        end
    })

    notify:AddLabel("Sleep")

    notify:AddToggle({
        Name = "Notify When Done Sleeping(0%)",
        Default = false,
        Save = true,
        Flag = "notifywhendonesleeping",
        Callback = function(Value)
            SleepNotifier = Value

            while task.wait() and SleepNotifier do
                if IsSleeping() then
                    local Fatigue = tonumber(game.Players.LocalPlayer.PlayerGui.MainGui.Utility.BodyFatigue.Text:split(" ")[3]:split("%")[1])
                    print(Fatigue)
                    if Fatigue <= 0 then
                        webhook("Sleep Notifier", "You're done sleeping! GET YO ASS UP!!!")
                        task.wait(60)
                    end
                end
            end
        end
    })

    notify:AddLabel("Food")

    notify:AddToggle({
        Name = "Notify & Stop when No Food",
        Default = false,
        Save = true,
        Flag = "notifyandstopwhennofood",
        Callback = function(Value)
            NoFoodNotify = Value
        end
    })

    notify:AddToggle({
        Name = "Log when No Food",
        Default = false,
        Save = true,
        Flag = "logwhennofood",
        Callback = function(Value)
            LogOnNoFood = Value
        end
    })

    dataTable = {
        discId = "",
        webhookUrl = "",
    }

    pcall(function()
        if isfile("Mighty_Omega.json") then
            local data = game:GetService("HttpService"):JSONDecode(readfile("Mighty_Omega.json"))
            dataTable["discId"] = data["discId"]
            dataTable["webhookUrl"] = data["webhookUrl"]
        else
            local data = game:GetService("HttpService"):JSONEncode(dataTable)
            writefile("Mighty_Omega.json", data)
        end
    end)


    notify_label = notify:AddLabel("Webhook Setup")

    notify:AddTextbox({
        Name = "Webhook Url",
        Default = "",
        TextDisappear = true,
        Save = false,
        Flag = "webhookurl",
        Callback = function(txt)
            webhookUrl = txt
            dataTable["webhookUrl"] = webhookUrl
            local data = game:GetService("HttpService"):JSONEncode(dataTable)
            if writefile then
                writefile("Mighty_Omega.json", data)
            end
        end
    })

    if dataTable["webhookUrl"] ~= "" then
        webhookUrl = dataTable["webhookUrl"]
        notify_label:Set(dataTable["webhookUrl"])
    end

    disc_id_label = notify:AddLabel("Discord User Id")

    notify:AddTextbox({
        Name = "Discord User Id",
        Default = "",
        TextDisappear = true,
        Save = false,
        Flag = "discorduserid",
        Callback = function(txt)
            if tonumber(txt) == nil then
                ping = "@everyone"
            else
                ping = "<@" .. txt .. ">"
                dataTable["discId"] = txt
                local data = game:GetService("HttpService"):JSONEncode(dataTable)
                if writefile then
                    writefile("Mighty_Omega.json", data)
                end
            end
        end
    })

    if dataTable["discId"] ~= "" then
        ping = "<@" .. dataTable["discId"] .. ">"
        disc_id_label:Set(dataTable["discId"])
    end

    notify:AddButton({
        Name = "Test Webhook",
        Callback = function()
            webhook("Webhook Test", "<3")
        end
    })

    autocook:AddLabel("Auto Cooking")

    pcall(function()
        autocook:AddToggle({
            Name = "Auto Cook",
            Default = false,
            Save = true,
            Flag = "autocook",
            Callback = function(Value)
                acook = Value

                while task.wait() and acook do
                    if CheckForFood() and acook then
                        local Pan

                        repeat
                            task.wait()
                        until GetPan() ~= nil or not acook
                        if not acook then
                            return
                        end
                        Pan = GetPan()

                        game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                        task.wait()
                        for i, v in pairs(recipes[SelectedFood]) do
                            local tool = game.Players.LocalPlayer.Backpack:FindFirstChild(i)
                            game.Players.LocalPlayer.Character.Humanoid:EquipTool(tool)
                            task.wait()
                            if not acook then
                                return
                            end
                            local potdebounce = false
                            repeat
                                if Pan.Ingredients:FindFirstChild(i) then
                                    if Pan.Ingredients:FindFirstChild(i).Value ~= v and not potdebounce then
                                        potdebounce = true
                                        VIM:SendKeyEvent(true, "E", false, game)
                                        task.wait(0.1)
                                        VIM:SendKeyEvent(false, "E", false, game)
                                        task.wait(0.1)
                                        potdebounce = false
                                    end
                                elseif not Pan.Ingredients:FindFirstChild(i) and not potdebounce then
                                    potdebounce = true
                                    VIM:SendKeyEvent(true, "E", false, game)
                                    task.wait(0.1)
                                    VIM:SendKeyEvent(false, "E", false, game)
                                    task.wait(0.1)
                                    potdebounce = false
                                end
                            until Pan.Ingredients:FindFirstChild(i) and Pan.Ingredients:FindFirstChild(i).Value == v or not acook
                            if not acook then
                                return
                            end
                            task.wait()
                            game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                            task.wait(0.1)
                        end
                        task.wait()
                        game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                        task.wait()
                        if Pan and acook then
                            if not acook then
                                return
                            end
                            fireclickdetector(Pan.ClickDetector)
                            task.wait()
                            repeat
                                task.wait()
                            until Pan.FoodP.TimeG.TextLabel.Text == "!!" or not acook
                            if not acook then
                                return
                            end
                            fireclickdetector(Pan.ClickDetector)
                            task.wait()
                        end
                    end
                end
            end
        })

        local foodlist = {}
        for i, v in pairs(recipes) do
            foodlist[#foodlist + 1] = i
        end

        autocook:AddDropdown({
            Name = "Food to Auto Cook",
            Options = foodlist,
            Save = true,
            Flag = "foodtocook",
            Callback = function(Value)
                SelectedFood = Value
            end
        })

        autocook:AddLabel("Auto Buy Ingredients")

        absbox = autocook:AddTextbox({
            Name = "Serving's",
            Save = true,
            Flag = "servings",
            Callback = function(txt)
                if tonumber(txt) ~= nil then
                    if tonumber(txt) > 8 then
                        absbox:Set("8")
                        TotalServings = 8
                    elseif tonumber(txt) < 1 then
                        absbox:Set("1")
                        TotalServings = 1
                    else
                        TotalServings = tonumber(txt)
                    end
                else
                    absbox:Set("1")
                end
            end
        })

        autocook:AddButton({
            Name = "Auto Buy Ingredients to Serving Size",
            Callback = function()
                if SelectedFood ~= nil then
                    for i, v in pairs(recipes[SelectedFood]) do
                        local finished = false
                        local start = tick()
                        local timesbought = 0
                        local required = v
        
                        if TotalServings > 1 then
                            required = v * TotalServings
                            if required > 15 then
                                required = 15
                            end
                        end
        
                        OrionLib:MakeNotification({
                            Name = "Auto Buy",
                            Content = "Auto Buying RN: " .. i .. "(" .. timesbought .. "/" .. required .. ")",
                            Image = "rbxassetid://4483345998", 
                            Time = 5,
                        })
        
                        local function GetPossibleBuyingRN()
                            local ingreds = {}
        
                            for _, child in pairs(workspace["Grocery Suburb"]:GetChildren()) do
                                if child.Name:find(i) then
                                    table.insert(ingreds, child)
                                end
                            end
        
                            return ingreds
                        end
        
                        local ingredLocations = GetPossibleBuyingRN()
        
                        repeat
                            for _, child in pairs(ingredLocations) do
                                local distance = (child.Head.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
        
                                if distance <= 5 then
                                    repeat
                                        fireclickdetector(child.ClickDetector)
                                        task.wait(0.1)
                                    until child.Name ~= "Purchased!"
                                    timesbought = timesbought + 1
                                    OrionLib:MakeNotification({
                                        Name = "Auto Buy Update",
                                        Content = "Auto Buying RN: " .. i .. "(" .. timesbought .. "/" .. required .. ")",
                                        Image = "rbxassetid://4483345998",
                                        Time = 5,
                                    })
                                    task.wait(0.5)
                                end
                                task.wait()
                            end
        
                            if game.Players.LocalPlayer.Backpack:FindFirstChild(i) then
                                if timesbought >= required or game.Players.LocalPlayer.Backpack:FindFirstChild(i).Quantity.Value >= 15 then
                                    finished = true
                                    break
                                end
                            elseif (tick() - start) >= 1200 then
                                OrionLib:MakeNotification({
                                    Name = "Auto Buy Error",
                                    Content = "Auto Buy Timed Out!",
                                    Image = "rbxassetid://4483345998",
                                    Time = 5,
                                })
                                return
                            end
                            task.wait()
                        until finished
                    end
                    OrionLib:MakeNotification({
                        Name = "Auto Buy Complete",
                        Content = "Finished Buying Ingredients for " .. TotalServings .. " Serving(s)",
                        Image = "rbxassetid://4483345998",
                        Time = 5,
                    })
                end
            end
        })       

        absbox:Set("1") 
    end)

    misc:AddLabel("Food Stuff")

    misc:AddToggle({
        Name = "Auto Eat",
        Default = false,
        Save = true,
        Flag = "autoeat",
        Callback = function(Value)
            autoeat = Value
            maintenancechecks()
        end
    })

    misc:AddSlider({
        Name = "Eat at Hunger %",
        Min = 0,
        Max = 100,
        Default = 30,
        Color = Color3.fromRGB(246, 255, 0),
        ValueName = "Value",
        Save = true,
        Flag = "eatathunger",
        Callback = function(Value)
            EatAt = Value
        end
    })

    misc:AddSlider({
        Name = "Fill up to Hunger %",
        Min = 0,
        Max = 100,
        Default = 80,
        Color = Color3.fromRGB(221, 230, 0),
        ValueName = "Value",
        Save = true,
        Flag = "filluphunger",
        Callback = function(Value)
            FillUp = Value
        end
    })

    misc:AddToggle({
        Name = "Dont Eat When In Combat",
        Default = false,
        Save = true,
        Flag = "donteatincombat",
        Callback = function(Value)
            stopAEinCombat = Value
        end
    })


    misc:AddToggle({
        Name = "Auto Buy Foods Nearby",
        Default = false,
        Save = true,
        Flag = "autobuyfoodsnearby",
        Callback = function(Value)
            autobuyitem = Value

            if autobuyitem then
                local function GetClosestItem()
                    local foodsnear = {}

                    for i, v in pairs(ItemTable) do
                        if (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Head.Position).Magnitude <= v.ClickDetector.MaxActivationDistance then
                            table.insert(foodsnear, v)
                        end
                    end

                    return foodsnear
                end

                while autobuyitem and task.wait() do
                    local foodstobuy = GetClosestItem()

                    if autobuyitem and #GetClosestItem() > 0 then
                        for i, v in pairs(foodstobuy) do
                            if autobuyitem == false then
                                return
                            end
                            fireclickdetector(v.ClickDetector)
                            task.wait(0.23)
                        end
                    end
                end
            end
        end
    })

    function GetClosestFood()
        local Closest, ClosestDistance = nil, math.huge
        for i, v in pairs(ItemTable) do
            if (v.Head.Position - player.Character.HumanoidRootPart.Position).Magnitude <= ClosestDistance  and v.Name:find(FoodToBuy) then
                Closest = v
                ClosestDistance = (v.Head.Position - player.Character.HumanoidRootPart.Position).Magnitude
            end
        end
        return Closest
    end

    FoodToBuy = nil
    PathForFood = false
    misc:AddDropdown({
        Name = "Food to Auto Buy(Recommended to select whatever is closest to u)",
        Default = false,
        Options = MOfoods,
        Save = true,
        Flag = "foodtoautobuy",
        Callback = function(value)
            FoodToBuy = value
            local asd = GetClosestFood()
            if asd then
                local check = checkForPath(asd.Head.Position)
                if check == "No path" then
                    PathForFood = false
                    OrionLib:MakeNotification({
                        Name = "Auto Buy Food",
                        Content = "Please select a different food, pathfinding cannot find a path to the currently selected one",
                        Image = "rbxassetid://4483345998",
                        Time = 5
                    })
                elseif check == "Success" then PathForFood = true end
            end
        end
    })

    AmountFoodToBuy = 8
    misc:AddSlider({
        Name = "Amount To Buy",
        Default = 8,
        Min = 1,
        Max = 12,
        Increment = 1,
        Color = Color3.fromRGB(220,20,60),
        ValueName = "Value",
        Save = true,
        Flag = "amountoffoodtobuy",
        Callback = function(value)
            AmountFoodToBuy = value
        end
    })
    
    function lookAt(lookAtVec)
        pcall(function()
            player.Character.HumanoidRootPart.CFrame = CFrame.new(player.Character.HumanoidRootPart.Position, lookAtVec)
        end)
    end

    getgenv().food = {}

    do
        local mt = {
            __newindex = function(self, idx, val)
                if val == false and tostring(idx) ~= "BuyingFood" then
                    rawset(self, "BuyingFood", false)
                    print("Set BuyingFood to false")
                end
                rawset(self, idx, val)
            end
        }
        setmetatable(food, mt)
    end
    
    getgenv().food.AutoBuyFood = false
    getgenv().food.AutoBuyFoodKungFu = false
    getgenv().food.BuyingFood = false
    NoPathFor = {}
    misc:AddToggle({
        Name = "Auto Buy Food",
        Default = false,
        Save = true,
        Flag = "autobuyfood",
        Callback = function(state)
            getgenv().food.AutoBuyFood = state
            if not getgenv().food.AutoBuyFood then
                getgenv().food.BuyingFood = false
                _G.OngoingPath = nil
            elseif getgenv().food.AutoBuyFood then
                coroutine.wrap(function()
                    pcall(function()
                        while getgenv().food.AutoBuyFood and not getgenv().food.BuyingFood do task.wait()
                            if getgenv().food.AutoBuyFood and not getgenv().food.BuyingFood then
                                local hungerpercent = (game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.StomachBar.BarF.Bar.AbsoluteSize.X / game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.StomachBar.BarF.AbsoluteSize.X) * 100
                                local foodfound = false
                                local HumanoidRootPart = player.Character.HumanoidRootPart
                                local char = player.Character
                                local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack:FindFirstChild("LocalS"))
                    
                                if hungerpercent <= EatAt then
                                    local FoodFound = false
                                    for i, v in pairs(MOfoods) do
                                        if player.Backpack:FindFirstChild(v) or player.Character:FindFirstChild(v) then
                                            FoodFound = true
                                            break
                                        end
                                    end
                                    if not FoodFound and PathForFood then
                                        local ClosestFood = GetClosestFood()
                                        if ClosestFood and ClosestFood:FindFirstChild("Head") then
                                            local OriginPos = HumanoidRootPart.Position
                                            disableAllTraining()
                                            game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                                            getgenv().food.BuyingFood = true
                                            foodWalk(ClosestFood.Head.Position)
                                            task.wait()
                                            local CurrMoney = tonumber((game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.Money.Text:gsub("%$", "")))
                                            repeat task.wait(0.23)
                                                fireclickdetector(ClosestFood.ClickDetector)
                                                task.wait()
                                                CurrMoney = tonumber((game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.Money.Text:gsub("%$", "")))
                                            until player.Backpack:FindFirstChild(FoodToBuy) or not getgenv().food.AutoBuyFood or CurrMoney < 80
                                            while (player.Backpack[FoodToBuy].Quantity.Value ~= AmountFoodToBuy and CurrMoney >= 80) or not getgenv().food.AutoBuyFood do
                                                fireclickdetector(ClosestFood.ClickDetector)
                                                task.wait()
                                                CurrMoney = tonumber((game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.Money.Text:gsub("%$", "")))
                                            end
                                            task.wait()
                                            foodWalk(OriginPos)
                                            task.wait()
                                            getgenv().food.BuyingFood = false
                                            actionscript.stopSprint()
                                            restoreTraining()
                                        end
                                    end
                                end
                            end
                        end
                    end)
                end)()
            end
        end
    })


    

    RamenShopPos = Vector3.new(-1127.8975830078125, 47.574039459228516, -293.36199951171875)
    misc:AddToggle({
        Name = "Auto Buy Food(Kung Fu)",
        Default = false,
        Save = true,
        Flag = "autobuyfoodkungfu",
        Callback = function(state)
            getgenv().food.AutoBuyFoodKungFu = state
            if not getgenv().food.AutoBuyFoodKungFu then
                getgenv().food.BuyingFood = false
                _G.OngoingPath = nil
            elseif getgenv().food.AutoBuyFoodKungFu then
                coroutine.wrap(function()
                    pcall(function()
                        while getgenv().food.AutoBuyFoodKungFu and not getgenv().food.BuyingFood do task.wait()
                            if getgenv().food.AutoBuyFoodKungFu and not getgenv().food.BuyingFood then
                                local hungerpercent = (game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.StomachBar.BarF.Bar.AbsoluteSize.X / game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.StomachBar.BarF.AbsoluteSize.X) * 100
                                local foodfound = false
                                local HumanoidRootPart = player.Character.HumanoidRootPart
                                local char = player.Character
                                local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack:FindFirstChild("LocalS"))
                    
                                if hungerpercent <= EatAt then
                                    local FoodFound = false
                                    for i, v in pairs(MOfoods) do
                                        if player.Backpack:FindFirstChild(v) or player.Character:FindFirstChild(v) then
                                            FoodFound = true
                                            break
                                        end
                                    end
                                    if not FoodFound then
                                        local OriginPos = HumanoidRootPart.Position
                                        local OriginLookVector = HumanoidRootPart.CFrame.LookVector
                                        disableAllTraining()
                                        getgenv().food.BuyingFood = true
                                        game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                                        task.wait(0.1)
                                        ----[[
                                        foodWalkKungFu(Vector3.new(-1102.9478759765625, 47.59747314453125, 122.28337860107422))
                                        foodWalkKungFu(Vector3.new(-1145.41845703125, 46.774166107177734, -2.053133964538574))
                                        foodWalkKungFu(Vector3.new(-1146.3226318359375, 46.77416229248047, -96.27108764648438))
                                        foodWalkKungFu(Vector3.new(-1141.9315185546875, 46.774166107177734, -192.78717041015625))
                                        foodWalkKungFu(Vector3.new(-1135.44091796875, 47.65406036376953, -226.77296447753906))
                                        foodWalkKungFu(Vector3.new(-1139.337890625, 47.574039459228516, -270.11138916015625))
                                        task.wait()
                                        print("moving to ramen")
                                        foodWalkKungFu(RamenShopPos)
                                        ----]]
                                        task.wait()
                                        for i,v in pairs(workspace.Map:GetChildren()) do
                                            if v:FindFirstChild("Shopnoid") and (v.Name:find("Ramen") or v.Name:find("Tofu Beef Soup") or v.Name:find("Tokito Sake") or v.Name:find("Chicken Fries")) then
                                                local VHead = v:FindFirstChild("Head")
                                                local VClickDetector = v:FindFirstChild("ClickDetector")
                                                local delim = ": $"
                                                
                                                local FoodName = v.Name:sub(1, v.Name:find(delim, 1, true) - 1)
                                                local CurrMoney = tonumber((game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.Money.Text:gsub("%$", "")))
                                                if (VHead.Position - HumanoidRootPart.Position).Magnitude <= VClickDetector.MaxActivationDistance then
                                                    if CurrMoney > 80 then
                                                        repeat
                                                            fireclickdetector(VClickDetector)
                                                            task.wait(0.5)
                                                            CurrMoney = tonumber((game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.Money.Text:gsub("%$", "")))
                                                        until player.Backpack:FindFirstChild(FoodName) or not getgenv().food.AutoBuyFoodKungFu
                                                        if player.Backpack:FindFirstChild(FoodName) then
                                                            while (player.Backpack[FoodName].Quantity.Value ~= AmountFoodToBuy and CurrMoney > 80) or not getgenv().food.AutoBuyFoodKungFu do
                                                                fireclickdetector(VClickDetector)
                                                                task.wait(0.5)
                                                                CurrMoney = tonumber((game:GetService("Players").LocalPlayer.PlayerGui.MainGui.Utility.Money.Text:gsub("%$", "")))
                                                            end
                                                        end
                                                        task.wait()
                                                    end
                                                end
                                            end
                                        end
                                        task.wait()
                                        ----[[
                                        print("Movign back")
                                        foodWalkKungFu(Vector3.new(-1139.337890625, 47.574039459228516, -270.11138916015625))
                                        foodWalkKungFu(Vector3.new(-1135.6181640625, 47.5941276550293, -225.6297607421875))
                                        foodWalkKungFu(Vector3.new(-1137.9814453125, 46.774166107177734, -201.88868713378906))
                                        foodWalkKungFu(Vector3.new(-1141.9315185546875, 46.774166107177734, -192.78717041015625))
                                        foodWalkKungFu(Vector3.new(-1146.3226318359375, 46.77416229248047, -96.27108764648438))
                                        foodWalkKungFu(Vector3.new(-1145.41845703125, 46.774166107177734, -2.053133964538574))
                                        foodWalkKungFu(Vector3.new(-1102.9478759765625, 47.59747314453125, 122.28337860107422))
                                        foodWalkKungFu(OriginPos)
                                        ----]]
                                        task.wait()
                                        lookAt(OriginLookVector)
                                        getgenv().food.BuyingFood = false
                                        actionscript.stopSprint()
                                        restoreTraining()
                                        task.wait()
                                    end
                                end
                            end
                        end
                    end)
                end)()
            end
        end
    })

    misc:AddLabel("Auto Supplement")

    misc:AddToggle({
        Name = "Auto Supplement",
        Default = false,
        Save = true,
        Flag = "autosupplement",
        Callback = function(Value)
            autosupplement = Value
        end
    })

    misc:AddToggle({
        Name = "Auto Multiple Supplements",
        Default = false,
        Save = true,
        Flag = "automultiplesupplements",
        Callback = function(Value)
            autosupplement2 = Value
        end
    })

    misc:AddSlider({
        Name = "Supplements Amm",
        Min = 0,
        Max = 12,
        Default = DrinkAmm,
        Color = Color3.fromRGB(220,20,60),
        ValueName = "Value",
        Increment = 1,
        Save = true,
        Flag = "supplementsamm",
        Callback = function(Value)
            DrinkAmm = Value
        end
    })

    misc:AddDropdown({
        Name = "Supplement",
        Options = {"BCAA", "Protein Shake", "Fat Burner", "Scalar"},
        Save = true,
        Flag = "supplement",
        Callback = function(Value)
            selectedsupplement = Value
        end
    })

    misc:AddLabel("Extra's")

    misc:AddToggle({
        Name = "Hold Click (Tools)",
        Default = false,
        Save = true,
        Flag = "holdclicktools",
        Callback = function(Value)
            holdclick = Value

            while task.wait() and holdclick do
                if UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
                    while UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) and task.wait() do
                        pcall(function()
                            if UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
                                game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):Activate()
                            end
                        end)
                    end
                end
            end
        end
    })

    ls = game.Players.LocalPlayer.Backpack:FindFirstChild("LocalS")
    if not ls then
        warn("LocalS script not found in Backpack")
    end

    height = nil
    print(ls)
    function update_height()
        ls_senv = getsenv(ls)
        for _, v in pairs(ls_senv) do
            if typeof(v) == "function" then
                for _, upval in pairs(debug.getupvalues(v)) do
                    if typeof(upval) == "table" and upval["Height"] then
                        height = upval["Height"]
                    end
                end
            end
        end
    end

    auto_height_reroll = false
    height_to_roll_for = nil
    misc:AddToggle({
        Name = "Auto Height Reroll",
        Default = false,
        Save = false,
        Flag = "autoheightreroll",
        Callback = function(state)
            auto_height_reroll = state
            task.spawn(function()
                while auto_height_reroll do task.wait()
                    update_height()
                    if height_to_roll_for == "1.2 - 1.3(50%)" then
                        SimulateClick(game:GetService("Players").LocalPlayer.PlayerGui.EventGUI.Holder.Main.Shop.BuyButton, "Function")
                        task.wait(1)
                        update_height()
                        task.wait()
                        if height >= 1.2 and height <= 1.3 then
                            break
                        end
                    elseif height_to_roll_for == "1.3 - 1.4(40%)" then
                        SimulateClick(game:GetService("Players").LocalPlayer.PlayerGui.EventGUI.Holder.Main.Shop.BuyButton, "Function")
                        task.wait(1)
                        update_height()
                        task.wait()
                        if height >= 1.3 and height <= 1.4 then
                            break
                        end
                    elseif height_to_roll_for == "1.4 - 1.5(7%)" then
                        SimulateClick(game:GetService("Players").LocalPlayer.PlayerGui.EventGUI.Holder.Main.Shop.BuyButton, "Function")
                        task.wait(1)
                        update_height()
                        task.wait()
                        if height >= 1.4 and height <= 1.5 then
                            break
                        end
                    elseif height_to_roll_for == "1.5 - 1.6(3%)" then
                        SimulateClick(game:GetService("Players").LocalPlayer.PlayerGui.EventGUI.Holder.Main.Shop.BuyButton, "Function")
                        task.wait(1)
                        update_height()
                        task.wait()
                        if height >= 1.5 and height <= 1.6 then
                            break
                        end
                    end
                end
            end)
        end
    })
    misc:AddDropdown({
        Name = "Height to Reroll for",
        Default = nil,
        Options = {"1.2 - 1.3(50%)", "1.3 - 1.4(40%)", "1.4 - 1.5(7%)", "1.5 - 1.6(3%)"},
        Save = true,
        Flag = "heighttorollfor",
        Callback = function(value)
            height_to_roll_for = value
        end
    })

    misc:AddToggle({
        Name = "Auto Sprint (Combat)",
        Default = false,
        Save = true,
        Flag = "autosprintcombat",
        Callback = function(Value)
            autosprintcombat = Value

            local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack.LocalS)

            if autosprintcombat then
                began = game:GetService("UserInputService").InputBegan:Connect(function(input, chat)
                    if chat then
                        return
                    end
                    if input.KeyCode == Enum.KeyCode.W and not holdingW and autosprintcombat then
                        actionscript.runPrompt()
                        holdingW = true
                    end
                end)

                ended = game:GetService("UserInputService").InputEnded:Connect(function(input, chat)
                    if chat then
                        return
                    end
                    if input.KeyCode == Enum.KeyCode.W and holdingW and autosprintcombat then
                        holdingW = false
                    end
                end)
            else
                if began and ended then
                    began:Disconnect()
                    ended:Disconnect()
                end
            end
        end
    })

    misc:AddLabel("Disable Training's")

    misc:AddToggle({
        Name = "Disable Trainings When InCombat",
        Default = false,
        Save = true,
        Flag = "disabletrainingwhencombat",
        Callback = function(Value)
            StopInCombat = Value

            while task.wait() and StopInCombat do
                if game.Players.LocalPlayer.PlayerGui.MainGui.Utility.CombatTag.Visible then
                    disableAllTraining()
                    task.wait(2)
                end
            end
        end
    })

    misc:AddToggle({
        Name = "Disable Trainings When Knocked",
        Default = false,
        Save = true,
        Flag = "disabletrainingswhenknocked",
        Callback = function(Value)
            StopKnocked = Value

            while task.wait() and StopKnocked do
                if game.Players.LocalPlayer.Character:FindFirstChild("Ragdolled").Value == true then
                    disableAllTraining()
                    task.wait(2)
                end
            end
        end
    })

    misc:AddLabel("ServerH / RJ")

    misc:AddButton({
        Name = "Serverhop to Lowest Server",
        Callback = function()
            local Http = game:GetService("HttpService")
            local TPS = game:GetService("TeleportService")
            local Api = "https://games.roblox.com/v1/games/"

            local _place = game.PlaceId
            local _servers = Api .. _place .. "/servers/Public?sortOrder=Asc&limit=100"
            function ListServers(cursor)
                local Raw = game:HttpGet(_servers .. ((cursor and "&cursor=" .. cursor) or ""))
                return Http:JSONDecode(Raw)
            end

            local Server, Next
            repeat
                local Servers = ListServers(Next)
                Server = Servers.data[1]
                Next = Servers.nextPageCursor
            until Server

            TPS:TeleportToPlaceInstance(_place, Server.id, game.Players.LocalPlayer)
        end
    })

    misc:AddButton({
        Name = "Serverhop to Random Server",
        Callback = function()
            local httprequest = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
            if httprequest then
                local servers = {}
                local HttpService = game:GetService("HttpService")
                local TeleportService = game:GetService("TeleportService")
                local PlaceID = game.PlaceId
                local req = httprequest({Url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100&excludeFullGames=true", PlaceID)})
                local body = HttpService:JSONDecode(req.Body)

                if body and body.data then
                    for _, v in ipairs(body.data) do
                        if type(v) == "table" and v.playing < v.maxPlayers and v.id ~= game.JobId then
                            table.insert(servers, v.id)
                        end
                    end
                end

                if #servers > 0 then
                    TeleportService:TeleportToPlaceInstance(PlaceID, servers[math.random(1, #servers)], player)
                end
            end
        end
    })

    misc:AddButton({
        Name = "Rejoin",
        Callback = function()
            
            local teleportService = game:GetService("TeleportService")
            teleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
        end
    })

    misc:AddLabel("Disable Training's")

    misc:AddToggle({
        Name = "Auto Panic",
        Default = false,
        Save = true,
        Flag = "autopanic",
        Callback = function(Value)
            autopanic = Value

            local function IsInCombat()
                local status

                local suc = pcall(function()
                    if game.Players.LocalPlayer:FindFirstChild("PlayerGui") then
                        if game.Players.LocalPlayer.PlayerGui:FindFirstChild("MainGui") then
                            status = game.Players.LocalPlayer.PlayerGui.MainGui.Utility.CombatTag.Visible
                        end
                    end
                end)

                if not suc then
                    status = nil
                end

                return status
            end

            while task.wait() and autopanic do
                if IsInCombat() == true and autopanic then
                    disableAllTraining()
                    game.Players.LocalPlayer.Character.Humanoid:UnequipTools()

                    if macroruin then
                        webhook("Auto Panic", CurrentGanker .. " activated Combat Sequence!")
                    end

                    task.wait(1)

                    task.spawn(function()
                        while task.wait(panicdelay) and autopanic do
                            pcall(function()
                                local chance = math.random(1, 4)
                                if chance >= 2 then
                                    panicangle = panicangle * -1
                                end

                                game.Workspace.CurrentCamera.CFrame = game:GetService("Workspace").CurrentCamera.CFrame * CFrame.Angles(0, math.rad(panicangle), 0)
                                panicangle = math.random(35, 90)
                            end)
                        end
                    end)

                    task.spawn(function()
                        shared.AllowSprinting = false
                        local function IsDraining()
                            local lastStamVal = game.Players.LocalPlayer.Character.CurrentStamina.Value

                            task.wait(0.5)
                            if lastStamVal > game.Players.LocalPlayer.Character.CurrentStamina.Value then
                                return true
                            end
                            return false
                        end

                        while task.wait(0.1) and autopanic do
                            pcall(function()
                                local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack.LocalS)
                                local StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                                local LowStam = ministam

                                if isrunning == false and CurrentRegening == false and shared.AllowSprinting then
                                    actionscript.runPrompt()
                                    isrunning = true
                                    task.wait(1)
                                elseif isrunning == true and shared.AllowSprinting then
                                    repeat
                                        StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                                        task.wait()
                                    until CurrentRegening == true or StamPercent == 100 or autopanic == false or shared.AllowSprinting == false or IsDraining() == false

                                    if StamPercent <= ministam or shared.AllowSprinting == false or autopanic == false or CurrentRegening == true then
                                        actionscript.stopSprint()
                                    end
                                    isrunning = false
                                elseif isrunning == true and shared.AllowSprinting == false then
                                    actionscript.stopSprint()
                                    isrunning = false
                                end
                            end)
                        end

                        shared.AllowSprinting = false
                    end)

                    repeat
                        task.wait()
                        pcall(function()
                            panicstamcheck()

                            if game.Players.LocalPlayer.Character.Humanoid.MoveDirection == Vector3.new(0, 0, 0) then
                                automacrosprint()
                            else
                                panicdash()
                            end
                        end)
                    until IsInCombat() == false or autopanic == false
                    shared.AllowSprinting = false
                    if autopanic then
                        if macroruin then
                            webhook("Auto Panic", "Logged Safely!")
                            task.wait()
                        end

                        game:shutdown()
                        return
                    end
                end
            end
        end
    })

    misc:AddSlider({
        Name = "Keep Stamina Below %",
        Min = 0,
        Max = 100,
        Default = 20,
        Color = Color3.fromRGB(0, 92, 230),
        ValueName = "Value",
        Save = true,
        Flag = "keepstaminabelow",
        Callback = function(Value)
            staminabelowpercent = Value
        end
    })

    misc:AddToggle({
        Name = "Auto Disable Macros",
        Default = false,
        Save = true,
        Flag = "autodisablemacros",
        Callback = function(Value)
            AutoStop = Value
            maintenancechecks()
        end
    })

    misc:AddToggle({
        Name = "Use Obstacle Detection",
        Default = true,
        Save = true,
        Flag = "useobstacledetection",
        Callback = function(state)
            useObstacleDetection = state
        end
    })

    misc:AddSlider({
        Name = "Fatigue % to Stop",
        Min = 0,
        Max = 100,
        Default = FatigueToStop,
        Color = Color3.fromRGB(0, 92, 230),
        ValueName = "Value",
        Save = true,
        Flag = "fatigueperctostop",
        Callback = function(Value)
            FatigueToStop = Value
        end
    })

    misc:AddLabel("ESP's")

    misc:AddToggle({
        Name = "Player ESP",
        Default = false,
        Save = true,
        Flag = "playeresp",
        Callback = function(Value)
            ESP = Value
    
            if ESP then
                for _, v in pairs(game.Players:GetPlayers()) do
                    esp(v)
                end
    
                local plrconnection
                plrconnection = game.Players.PlayerAdded:Connect(function(plr)
                    if ESP == false then
                        plrconnection:Disconnect()
                        return
                    end
                    esp(plr)
                end)
    
                game.Players.PlayerRemoving:Connect(function(plr)
                    removeESP(plr)
                end)
            else
                for _, v in pairs(game.Players:GetPlayers()) do
                    removeESP(v)
                end
            end
        end
    })

    misc:AddToggle({
        Name = "Candy ESP",
        Default = false,
        Save = true,
        Flag = "candyesp",
        Callback = function(Value)
            CESP = Value
            while CESP do  task.wait(5)
                Candyesp()
            end
            RemoveAllESP()
        end
    })

    misc:AddSlider({
        Name = "ESP Distance",
        Min = 0,
        Max = 10000,
        Default = 10000,
        Color = Color3.fromRGB(207, 158, 255),
        ValueName = "Value",
        Increment = 1,
        Save = true,
        Flag = "espdistance",
        Callback = function(Value)
            ESPDistance = Value
        end
    })


    function press(btn)
        local inset = game:GetService("GuiService"):GetGuiInset()
        local aPos, aSize = btn.AbsolutePosition, btn.AbsoluteSize
        local vim = game:GetService("VirtualInputManager")
        vim:SendMouseButtonEvent(inset.X + aPos.X + aSize.X / 2, inset.Y + aPos.Y + aSize.Y / 2, 0, true, nil, 1)
        vim:SendMouseButtonEvent(inset.X + aPos.X + aSize.X / 2, inset.Y + aPos.Y + aSize.Y / 2, 0, false, nil, 1)
    end

    
    misc:AddToggle({
        Name = "Auto Open Crate",
        Default = false,
        Save = true,
        Flag = "autoopencrate",
        Callback = function(Value)
            autoOpenCrate = Value
            while task.wait(0.3) and autoOpenCrate do
                local crateGUI = game:GetService("Players").LocalPlayer.PlayerGui.CrateGUI
                local animationHolder = crateGUI.Animation.Holder
                if animationHolder.Visible == true then
                    local attemptCount = 0
                    while animationHolder.Visible and attemptCount < 4 do
                        press(animationHolder.Accept)
                        attemptCount = attemptCount + 1
                        task.wait(0.2)
                    end
                    if animationHolder.Visible then
                        press(animationHolder.Decline)
                    end
                else
                    local halloweenCrate = crateGUI.Main.Holder.Crates.Items["Halloween Crate #1"]
                    press(halloweenCrate.Open)
                end
            end
        end
    })
    

    misc:AddLabel("Starving")

    misc:AddToggle({
        Name = "Auto Starve",
        Default = false,
        Save = true,
        Flag = "autostarve",
        Callback = function(Value)
            autostarve = Value

            while task.wait() and autostarve do
                local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack.LocalS)
                local StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value / game.Players.LocalPlayer.Character.MaxStamina.Value) * 100

                if StamPercent >= staminabelowpercent and ASisrunning == false and game.Players.LocalPlayer.Character:FindFirstChild("Ragdolled").Value == false then
                    actionscript.runPrompt()
                    ASisrunning = true
                elseif StamPercent <= staminabelowpercent and ASisrunning then
                    task.wait(0.1)
                    ASisrunning = false
                elseif StamPercent == 100 then
                    task.wait(0.5)
                    if StamPercent == 100 then
                        ASisrunning = false
                    end
                end
            end
        end
    })

    misc:AddLabel("Note: consider auto sleep as risky |g Do Nothing is default")

    misc:AddDropdown({
        Name = "When Macro Stopped",
        Options = { "Do Nothing", "Log/Leave game", "Auto Sleep & Log", "Auto Sleep & Continue" },
        Save = true,
        Flag = "whenmacrostopped",
        Callback = function(Value)
            if Value == "Do Nothing" then
                LogOnFatigued = false
                autosleepRes = false
                autosleepLog = false
            elseif Value == "Log/Leave game" then
                LogOnFatigued = true
                autosleepRes = false
                autosleepLog = false
            elseif Value == "Auto Sleep & Log" then
                LogOnFatigued = false
                autosleepRes = false
                autosleepLog = true
            elseif Value == "Auto Sleep & Continue" then
                LogOnFatigued = false
                autosleepRes = true
                autosleepLog = false
            else
                LogOnFatigued = false
                autosleepRes = false
                autosleepLog = false
            end
        end
    })
    
    
   
    
    if hookmetamethod then
        Backup = hookmetamethod(
            Mouse,
            "__index",
            newcclosure(function(self, idx)
                if idx == "Target" and restockactive and restockpart ~= nil and autojobs then
                    return restockpart
                end

                return Backup(self, idx)
            end)
        )
    end


    risky:AddLabel("Jobs")
    
    WaitUntilRunning = false
    risky:AddToggle({
        Name = "Wait Until Running To Jump(Auto Job)",
        Default = false,
        Save = true,
        Flag = "waituntilrunningtojump",
        Callback = function(state)
            WaitUntilRunning = state
        end
    })

    japaneseSupplyPos = {
        Vector3.new(-1135.546142578125, 47.57412338256836, -221.89768981933594),
        Vector3.new(-1135.523193359375, 47.57414627075195, -225.21755981445312),
        Vector3.new(-1135.5145263671875, 47.63408279418945, -226.59945678710938),
        Vector3.new(-1135.5101318359375, 47.67403793334961, -227.29840087890625),
        Vector3.new(-1135.5233154296875, 47.59403610229492, -228.9292449951172),
        Vector3.new(-1140.0723876953125, 47.574039459228516, -250.97108459472656),
    }

    destroyedDoor = false

    risky:AddToggle({
        Name = "Auto Job",
        Default = false,
        Save = true,
        Flag = "autojob",
        Callback = function(Value)
            autojobs = Value

            if autojobs == false then
                _G.OngoingPath = false
            end

            local og = Vector3.new(2.6999998092651367, 45.04999923706055, 222.13999938964844)
            local new = Vector3.new(2.7, 45.05, 73.14)
            local AUTOJOBBARRIERS = {}
            AUTOJOBBARRIERS[1] = Instance.new("Part", workspace)
            AUTOJOBBARRIERS[1].Position = Vector3.new(-252.3034210205078, 54.62002182006836, -584.091064453125)
            AUTOJOBBARRIERS[1].Orientation = Vector3.new(0, 0, 0)
            AUTOJOBBARRIERS[1].Size = Vector3.new(28.020000457763672, 21.84000015258789, 3.559999942779541)
            AUTOJOBBARRIERS[1].Anchored = true
            AUTOJOBBARRIERS[1].CanCollide = true
            AUTOJOBBARRIERS[1].Transparency = 1
            AUTOJOBBARRIERS[2] = Instance.new("Part", workspace)
            AUTOJOBBARRIERS[2].Position = Vector3.new(287.8071594238281, 47.193782806396484, -902.21875)
            AUTOJOBBARRIERS[2].Orientation = Vector3.new(0, 0, 0)
            AUTOJOBBARRIERS[2].Size = Vector3.new(2.6999998092651367, 45.04999923706055, 222.13999938964844)
            AUTOJOBBARRIERS[2].Anchored = true
            AUTOJOBBARRIERS[2].CanCollide = true
            AUTOJOBBARRIERS[2].Transparency = 1
            AUTOJOBBARRIERS[4] = Instance.new("Part", workspace)
            AUTOJOBBARRIERS[4].Position = Vector3.new(-285.6453552246094, 48.400028228759766, -564.8450927734375)
            AUTOJOBBARRIERS[4].Orientation = Vector3.new(0, -30, 0)
            AUTOJOBBARRIERS[4].Size = Vector3.new(6.940000534057617, 10.199999809265137, 7.690000057220459)
            AUTOJOBBARRIERS[4].Anchored = true
            AUTOJOBBARRIERS[4].CanCollide = true
            AUTOJOBBARRIERS[4].Transparency = 1
            AUTOJOBBARRIERS[5] = Instance.new("Part", workspace)
            AUTOJOBBARRIERS[5].Position = Vector3.new(-306.9322204589844, 51.81392288208008, -615.2486572265625)
            AUTOJOBBARRIERS[5].Orientation = Vector3.new(0, 90, 0)
            AUTOJOBBARRIERS[5].Size = Vector3.new(34.63999938964844, 15.630000114440918, 5.739999294281006)
            AUTOJOBBARRIERS[5].Anchored = true
            AUTOJOBBARRIERS[5].CanCollide = true
            AUTOJOBBARRIERS[5].Transparency = 1
            AUTOJOBBARRIERS[6] = Instance.new("Part", workspace)
            AUTOJOBBARRIERS[6].Position = Vector3.new(-276.83843994140625, 51.203548431396484, -580.1591796875)
            AUTOJOBBARRIERS[6].Orientation = Vector3.new(0, 0, 0)
            AUTOJOBBARRIERS[6].Size = Vector3.new(2.9099998474121094, 14.970000267028809, 2.179999828338623)
            AUTOJOBBARRIERS[6].Anchored = true
            AUTOJOBBARRIERS[6].CanCollide = true
            AUTOJOBBARRIERS[6].Transparency = 1
            AUTOJOBBARRIERS[8] = Instance.new("Part", workspace)
            AUTOJOBBARRIERS[8].Position = Vector3.new(314.088134765625, 47.193782806396484, -790.2724609375)
            AUTOJOBBARRIERS[8].Orientation = Vector3.new(0, -89, 0)
            AUTOJOBBARRIERS[8].Size = Vector3.new(2.6999998092651367, 45.04999923706055, 55.47999954223633)
            AUTOJOBBARRIERS[8].Anchored = true
            AUTOJOBBARRIERS[8].CanCollide = true
            AUTOJOBBARRIERS[8].Transparency = 1
            AUTOJOBBARRIERS[9] = Instance.new("Part", workspace)
            AUTOJOBBARRIERS[9].Position = Vector3.new(287.8071594238281, 47.193782806396484, -671.853759765625)
            AUTOJOBBARRIERS[9].Orientation = Vector3.new(0, 0, 0)
            AUTOJOBBARRIERS[9].Size = Vector3.new(2.6999998092651367, 45.04999923706055, 218.58999633789062)
            AUTOJOBBARRIERS[9].Anchored = true
            AUTOJOBBARRIERS[9].CanCollide = true
            AUTOJOBBARRIERS[9].Transparency = 1
            AUTOJOBBARRIERS[10] = Instance.new("Part", workspace)
            AUTOJOBBARRIERS[10].Position = Vector3.new(314.088134765625, 47.193782806396484, -779.8624877929688)
            AUTOJOBBARRIERS[10].Orientation = Vector3.new(0, -89, 0)
            AUTOJOBBARRIERS[10].Size = Vector3.new(2.6999998092651367, 45.04999923706055, 55.47999954223633)
            AUTOJOBBARRIERS[10].Anchored = true
            AUTOJOBBARRIERS[10].CanCollide = true
            AUTOJOBBARRIERS[10].Transparency = 1
            AUTOJOBBARRIERS[11] = Instance.new("Part", workspace)
            AUTOJOBBARRIERS[11].Position = Vector3.new(-278.10223388671875, 51.81392288208008, -600.8236694335938)
            AUTOJOBBARRIERS[11].Orientation = Vector3.new(0, 0, 0)
            AUTOJOBBARRIERS[11].Size = Vector3.new(63.4900016784668, 15.630000114440918, 5.739999294281006)
            AUTOJOBBARRIERS[11].Anchored = true
            AUTOJOBBARRIERS[11].CanCollide = true
            AUTOJOBBARRIERS[11].Transparency = 1
            AUTOJOBBARRIERS[98] = Instance.new("Part", workspace)
            AUTOJOBBARRIERS[98].Position = Vector3.new(-1041.891, 59.14, -327.758)
            AUTOJOBBARRIERS[98].Orientation = Vector3.new(0, 0, 0)
            AUTOJOBBARRIERS[98].Size = Vector3.new(59, 32, 186)
            AUTOJOBBARRIERS[98].Anchored = true
            AUTOJOBBARRIERS[98].CanCollide = true
            AUTOJOBBARRIERS[98].Transparency = 1
            AUTOJOBBARRIERS[99] = Instance.new("Part", workspace)
            AUTOJOBBARRIERS[99].Position = Vector3.new(346.556, 25.2, -784.352)
            AUTOJOBBARRIERS[99].Orientation = Vector3.new(0, 90, 0)
            AUTOJOBBARRIERS[99].Size = Vector3.new(7, 1, 4)
            AUTOJOBBARRIERS[99].Anchored = true
            AUTOJOBBARRIERS[99].CanCollide = true
            AUTOJOBBARRIERS[99].Transparency = 1

            if autojobs then
                task.spawn(function()
                    shared.AllowSprinting = false

                    while task.wait(0.1) and autojobs do
                        pcall(function()
                            local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack.LocalS)
                            local StamPercent = (
                                game.Players.LocalPlayer.Character.CurrentStamina.Value
                                / game.Players.LocalPlayer.Character.MaxStamina.Value
                            ) * 100
                            local LowStam = ministam

                            if isrunning == false and StamPercent >= 100 and shared.AllowSprinting then
                                actionscript.runPrompt()
                                isrunning = true
                                task.wait(1)
                            elseif isrunning == true and shared.AllowSprinting then
                                repeat
                                    StamPercent = (
                                        game.Players.LocalPlayer.Character.CurrentStamina.Value
                                        / game.Players.LocalPlayer.Character.MaxStamina.Value
                                    ) * 100
                                    task.wait()
                                until StamPercent <= LowStam
                                    or StamPercent == 100
                                    or autojobs == false
                                    or shared.AllowSprinting == false

                                if StamPercent <= ministam or shared.AllowSprinting == false or autojobs == false then
                                    actionscript.stopSprint()
                                end
                                isrunning = false
                            elseif isrunning == true and shared.AllowSprinting == false then
                                actionscript.stopSprint()
                                isrunning = false
                            end
                        end)
                    end

                    shared.AllowSprinting = false
                end)

                local char = player.Character
                local hum = char.Humanoid
                local PFS = game:GetService("PathfindingService")
                local HRP = char.HumanoidRootPart
                local pathStatus = Enum.PathStatus
                local HumanoidRootPart = HRP

                _G.currentPoint = nil
                _G.OngoingPath = false

                local function createPath(point)
                    local currentPath = PFS:CreatePath({
                        AgentRadius = 1,
                        WaypointSpacing = 1.5,
                    })
                    currentPath:ComputeAsync(HRP.Position - Vector3.new(0, HRP.Position.Y/0.75, 0), point)
                    local pathExists = false

                    if currentPath.Status == pathStatus.Success then
                        pathExists = true
                        _G.OngoingPath = true

                        spawn(function()
                            while pathExists and task.wait() and _G.currentPoint ~= nil and _G.OngoingPath and autojobs do
                                local x, y = pcall(function()
                                    if (HRP.Position - _G.currentPoint).Magnitude > 5 then
                                        hum.WalkToPoint = _G.currentPoint
                                    end
                                end)
                                if not x then
                                    warn(y)
                                end
                            end
                        end)

                        local lastbroken = false
                        local antisusdebounce = false
                        local alreadychanced = false
                        local oldhumanpos, lastupdate = nil, nil

                        for i, v in pairs(currentPath:GetWaypoints()) do
                            if _G.OngoingPath ~= true then
                                return
                            end

                            if v.Action == Enum.PathWaypointAction.Jump then
                                if WaitUntilRunning then repeat task.wait() until isrunning end
                                hum:ChangeState(Enum.HumanoidStateType.Jumping)
                            end

                            local part = Instance.new("Part")
                            part.Shape = "Ball"
                            part.Material = "Neon"
                            part.Size = Vector3.new(0.6, 0.6, 0.6)
                            part.Position = v.Position + Vector3.new(0, 6, 0)
                            part.Anchored = true
                            part.CanCollide = false
                            part.Parent = game.Workspace

                            local oldpos = HRP.Position
                            local updatedelay = false

                            local function percentchance(x)
                                if 100 * math.random() < x then
                                    return true
                                else
                                    return false
                                end
                            end

                            if lastupdate == nil then
                                lastupdate = tick()
                            else
                                if (tick() - lastupdate) >= 2 then
                                    lastupdate = tick()
                                    oldhumawnpos = HRP.Position
                                end
                            end

                            repeat
                                task.wait()
                                if autojobs == false then
                                    game.Debris:AddItem(part, 0.01)
                                    return
                                end
                                _G.currentPoint = v.Position

                                if percentchance(3) and not antisusdebounce and alreadychanced == false then
                                    task.spawn(function()
                                        antisusdebounce = true
                                        shared.AllowSprinting = false
                                        task.wait(math.random(1, 3))
                                        if game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("JobGUI") then
                                            shared.AllowSprinting = true
                                        end
                                        antisusdebounce = false
                                    end)
                                end
                                alreadychanced = true

                                if
                                    (HRP.Position - v.Position).Magnitude > 5
                                    and (HRP.Position - part.Position).Magnitude > 4
                                then
                                    if oldpos ~= HRP.Position and not lastbroken and not updatedelay then
                                        task.spawn(function()
                                            updatedelay = true
                                            oldpos = HRP.Position
                                            task.delay(1, function()
                                                updatedelay = false
                                            end)
                                        end)
                                    elseif oldpos == HRP.Position and not lastbroken then
                                        oldpos = HRP.Position
                                        lastbroken = true
                                        break
                                    elseif oldpos == HRP.Position and lastbroken then
                                        task.spawn(function()
                                            task.wait(1)
                                            if oldpos == HRP.Position then
                                                hum:ChangeState(Enum.HumanoidStateType.Jumping)
                                                task.wait(1)
                                            end

                                            oldpos = HRP.Position
                                            lastbroken = false
                                        end)
                                    end
                                elseif oldhumanpos ~= nil then
                                    if (HRP.Position - oldhumanpos).Magnitude <= 0.05 then
                                        hum:ChangeState(Enum.HumanoidStateType.Jumping)
                                        task.wait(1)
                                    end
                                end
                            until (HRP.Position - v.Position).Magnitude < PointRangeTilNext
                                or (HRP.Position - part.Position).Magnitude < 5
                                or _G.OngoingPath ~= true
                                or autojobs == false
                            game.Debris:AddItem(part, 0.01)
                        end

                        _G.OngoingPath = false
                    elseif currentPath.Status ~= pathStatus.Success or _G.currentPoint == nil then
                        pathExists = false
                    end
                    return pathExists
                end

                local JobStuff = {
                    ["Convenience"] = {
                        JB = workspace.Map.JobBoardModel,
                        JBget = Vector3.new(-315.9144592285156, 47.29416275024414, -589.2377319335938),
                    },
                    ["Japanese1"] = {
                        JB = workspace.Map.JobBoardModel1,
                        JBget = Vector3.new(-1167, 47, -223),
                    },
                }

                while task.wait() and autojobs do
                    if SelectedJob == nil or JobBoard == nil then
                        repeat
                            task.wait()
                        until SelectedJob ~= nil and JobBoard ~= nil or autojobs == false
                    end
                    if game.Players.LocalPlayer.Character.Ragdolled.Value then
                        disableAllTraining()
                        if macroruin then
                            webhook("Macro Notifier", "Knocked/Ragdolled while doing Auto Job. Auto Job turned off")
                        end
                        return
                    end
                    shared.AllowSprinting = false
                    local JB = JobStuff[JobBoard].JB
                    local JBget = JobStuff[JobBoard].JBget
                    local jbdistance = (HRP.Position - JB.Board.Position).Magnitude
                    local jobui = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("JobGUI")
                    local cleared = false

                    if jobui == nil then
                        if jbdistance <= 9 then
                            maintenancechecks()
                            repeat
                                fireclickdetector(JB.ClickDetector)
                                task.wait()
                            until game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("JobGUI")
                        end
                    elseif jobui then
                        if
                            jobui.Frame.Title.Text:find("Restock") and SelectedJob == "Restock"
                            or SelectedJob == "All" and jobui.Frame.Title.Text:find("Restock")
                        then
                            cleared = true
                            AUTOJOBBARRIERS[2].Size = og
                        elseif
                            jobui.Frame.Title.Text:find("Cleaning") and SelectedJob == "Cleaning"
                            or SelectedJob == "All" and jobui.Frame.Title.Text:find("Cleaning")
                        then
                            if JobBoard == "Convenience" then
                                moveToPoint(Vector3.new(-370, 47, -582))
                            end

                            broomjobactive = true

                            repeat
                                task.wait()

                                local annoyingpart = game:GetService("Workspace").Jobs.BroomClean[JobBoard].Part9
                                if annoyingpart.Transparency ~= 1 then
                                    broomjobpart = annoyingpart
                                    if JobBoard == "Convenience" then
                                        moveToPoint(Vector3.new(-347, 47, -577))
                                    else
                                        moveToPoint(annoyingpart.Position)
                                    end
                                    task.wait(0.1)
                                    if game.Players.LocalPlayer.Backpack:FindFirstChild("Broom") then
                                        game.Players.LocalPlayer.Character.Humanoid:EquipTool(
                                            game.Players.LocalPlayer.Backpack:FindFirstChild("Broom")
                                        )
                                        task.wait(0.1)
                                    end

                                    VIM:SendMouseButtonEvent(0, 500, 0, true, game, 1)
                                    task.wait(0.1)
                                    repeat
                                        task.wait()
                                    until annoyingpart.Transparency == 1
                                end

                                local v = BestBroomSpot()

                                if v ~= nil then
                                    broomjobpart = v
                                    shared.currentPoint = nil
                                    moveToPoint(v.Position)
                                    task.wait(0.1)
                                    if game.Players.LocalPlayer.Backpack:FindFirstChild("Broom") then
                                        game.Players.LocalPlayer.Character.Humanoid:EquipTool(
                                            game.Players.LocalPlayer.Backpack:FindFirstChild("Broom")
                                        )
                                        task.wait(0.1)
                                    end

                                    VIM:SendMouseButtonEvent(0, 500, 0, true, game, 1)
                                    task.wait(0.1)
                                    repeat
                                        task.wait()
                                    until v.Transparency == 1
                                end

                            until game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("JobGUI") == nil
                                or autojobs == false

                            broomjobactive = false

                            if JobBoard == "Convenience" then
                                game.Players.LocalPlayer.Character.Humanoid:MoveTo(Vector3.new(-370, 47, -582))
                                game.Players.LocalPlayer.Character.Humanoid.MoveToFinished:Wait()
                            end
                            task.spawn(function()
                                createPath(JBget)
                            end)
                        else
                            SimulateClick(jobui.Frame.Quit, "Function")
                        end
                    end

                    if cleared then
                        local progress = tonumber(jobui.Frame.Progress.Text:split("/")[1]:split(":")[2])
                        print("[AUTO JOB] progress - ", progress)
                        if progress == 0 then
                            AUTOJOBBARRIERS[2].Size = og
                            task.delay(math.random(1, 3), function()
                                shared.AllowSprinting = true
                            end)
                            createPath(workspace.Jobs.SupplyDelivery[JobBoard].Part1.Position)
                            shared.AllowSprinting = false
                        elseif progress == 1 then
                            AUTOJOBBARRIERS[2].Size = new
                            task.delay(math.random(1, 3), function()
                                shared.AllowSprinting = true
                            end)
                            if JobBoard == "Japanese1" then
                                if not destroyedDoor then
                                    for i,v in pairs(workspace.Map:GetDescendants()) do
                                        if destroyedDoor then break end
                                        if v.Name == "Windows Door" and v.Position == Vector3.new(-1135.685546875, 47.79990005493164, -226.549560546875) then
                                            v:Destroy()
                                            destroyedDoor = true
                                        end
                                    end
                                end
                                for i,v in ipairs(japaneseSupplyPos) do
                                    print("[AUTO JOB JAPANESE] Moving to " .. tostring(v))
                                    createPath(v)
                                end
                            end
                            createPath(workspace.Jobs.SupplyDelivery[JobBoard].Part2.Position)
                            shared.AllowSprinting = false

                            task.delay(math.random(1, 3), function()
                                shared.AllowSprinting = true
                            end)
                            if JobBoard == "Japanese1" then
                                for i = #japaneseSupplyPos, 1, -1 do
                                    print("[AUTO JOB JAPANESE] Moving to " .. tostring(japaneseSupplyPos[i]))
                                    createPath(japaneseSupplyPos[i])
                                end
                            end
                            createPath(JBget)
                            shared.AllowSprinting = false
                        end
                    end
                end
            end

            if autojobs == false then
                for i, v in pairs(AUTOJOBBARRIERS) do
                    game.Debris:AddItem(v, 0.01)
                end
            end
        end
    })

    risky:AddDropdown({
        Name = "Job Selector",
        Default = "Restock",
        Options = {"Restock", "Cleaning", "All"},
        Save = true,
        Flag = "jobselect",
        Callback = function(Value)
            print("Job selected: ", Value)
            SelectedJob = Value
        end
    })

    risky:AddDropdown({
        Name = "Job Board",
        Default = "Japanese1",
        Options = {"Japanese1", "Convenience"},
        Save = true,
        Flag = "jobboard",
        Callback = function(Value)
            JobBoard = Value
        end
    })
    
    
    risky:AddLabel("If supply job stop randomly use Point mag below")

    risky:AddSlider({
        Name = "Point Magnitude Til Next",
        Min = 0,
        Max = 30,
        Default = PointRangeTilNext,
        Color = Color3.fromRGB(255, 255, 255),
        Increment = 1,
        ValueName = "Magnitude",
        Save = true,
        Flag = "pointmagnitudetilnext",
        Callback = function(Value)
            PointRangeTilNext = Value
        end
    })

    risky:AddLabel("Roadworks")

    risky:AddToggle({
        Name = "Auto Roadwork",
        Default = false,
        Save = true,
        Flag = "autoroadwork",
        Callback = function(Value)
            Roadwork = Value

            if Roadwork then
                task.spawn(function()
                    while task.wait(0.1) and Roadwork do
                        local actionscript = getsenv(game:GetService("Players").LocalPlayer.Backpack.LocalS)
                        local StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value/ game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                        local LowStam = ministam

                        if RWCanSprint and Roadwork then
                            if isrunning == false and StamPercent >= 100 and RWCanSprint then
                                actionscript.runPrompt()
                                isrunning = true
                                task.wait(1)
                            elseif isrunning == true then
                                repeat
                                    StamPercent = (game.Players.LocalPlayer.Character.CurrentStamina.Value/ game.Players.LocalPlayer.Character.MaxStamina.Value) * 100
                                    task.wait()
                                until StamPercent <= LowStam
                                    or StamPercent == 100
                                    or Roadwork == false
                                    or RWCanSprint == false

                                if StamPercent < 100 or Roadwork == false or RWCanSprint == false then
                                    actionscript.stopSprint()
                                    maintenancechecks()
                                end
                                isrunning = false
                            end
                        end
                    end
                end)

                while task.wait() and Roadwork do
                    pcall(function()
                        local MyStorage = workspace:FindFirstChild(game.Players.LocalPlayer.Name .. " Storage")
                        local RWBuy = GetClosestRoadwork()
                        if RWBuy and #MyStorage:GetChildren() < 1 then
                            --print("EWQE")
                            RWCanSprint = true
                            moveToPoint(RWBuy.Head.Position)
                        end
                        if game.Players.LocalPlayer.Backpack:FindFirstChild("Roadwork") == nil and game.Players.LocalPlayer.Character:FindFirstChild("Roadwork") == nil then
                            if RWBuy ~= nil then
                                RWCanSprint = true
                                --print("DDDD")
                                moveToPoint(RWBuy.Head.Position)
                                RWCanSprint = false
                                task.wait(0.1)
                                fireclickdetector(RWBuy.ClickDetector)
                                task.wait(0.1)
                            end
                        else
                            if #MyStorage:GetChildren() < 1 then
                                --print("ASD")
                                if game.Players.LocalPlayer.Backpack:FindFirstChild("Roadwork") then
                                    game.Players.LocalPlayer.Character.Humanoid:EquipTool(
                                        game.Players.LocalPlayer.Backpack:FindFirstChild("Roadwork")
                                    )
                                    task.wait(0.1)
                                end
                                game.Players.LocalPlayer.Character:FindFirstChild("Roadwork"):Activate()
                            else
                                --print("ASDDD")
                                RWCanSprint = true
                                createPath(MyStorage:GetChildren()[1].Position)
                            end
                        end
                    end)
                end
            end
        end
    })

    risky:AddLabel("If roadwork stop randomly use cp mag below")

    risky:AddSlider({
        Name = "CP Magnitude Til Next",
        Min = 0,
        Max = 30,
        Default = CPRangeTilNext,
        Color = Color3.fromRGB(255, 255, 255),
        Increment = 1,
        ValueName = "Magnitude",
        Save = true,
        Flag = "cpmagtilnext",
        Callback = function(Value)
            CPRangeTilNext = Value
        end
    })

    function ScanTable(table, string)
        for i, v in pairs(table) do
            if v == string then
                return i
            end
        end

        return nil
    end

    function AztupElements()
        local LivingThings
        LivingThings = workspace:FindFirstChild("Live") or Instance.new("Model")
        local Events = game.ReplicatedStorage.Events
        getgenv().runningSpeed = 500
        local ATBdistance = 10
        local ATBrange = 100
        local ATBloop = nil
        local angleOffSet = CFrame.Angles(math.rad(-90), 0, 0)

        local function UtilityFind(t, c)
            for i, v in next, t do
                if c(v, i) then
                    return v, i
                end
            end

            return nil
        end

         function parseKey(str)
            return UtilityFind({ str:byte(1, 9999) }, function(v)
                return v > 128
            end)
        end

         function getKey(script)
            if not script:IsA("LocalScript") then
                error("Expected a localscript got " .. script.ClassName)
            end
            local key

            local ran, env = pcall(getsenv, script)
            if not ran then
                return
            end

            for _, v in next, env do
                if typeof(v) == "function" then
                    for _, k in next, getupvalues(v) do
                        if typeof(k) == "string" and parseKey(k) then
                            key = k
                            break
                        end
                    end
                end
            end

            if key then
                return key
            end

            for _, v in next, script.Parent:GetDescendants() do
                local con = string.match(v.ClassName, "Button") and getconnections(v.MouseButton1Click)[1]
                    or getconnections(v.Changed)[1]
                if con and con.Function then
                    for _, k in next, getupvalues(v) do
                        if typeof(k) == "string" and parseKey(k) then
                            key = k
                            break
                        end
                    end

                    if key then
                        break
                    end
                end
            end
            return key
        end

        getgenv().getKey = getKey

         function getMobInRange(range)
            local plr = game.Players.LocalPlayer
            local char = plr.Character
            local inRange
            local closest = range
            for i, v in next, LivingThings:GetChildren() do
                if v ~= char then
                    if not game.Players:FindFirstChild(v.Name) then
                        if (v:FindFirstChild("HumanoidRootPart")) and char:FindFirstChild("HumanoidRootPart") then
                            if (v.HumanoidRootPart.Position - char.HumanoidRootPart.Position).magnitude <= closest then
                                inRange = v
                                closest = (v.HumanoidRootPart.Position - char.HumanoidRootPart.Position).magnitude
                                break
                            end
                        end
                    end
                end
            end

            return inRange
        end

         plr = game.Players.LocalPlayer
         char = plr.Character
         getupvalue = debug.getupvalue
         getupvalues = debug.getupvalues
         getconstant = debug.getconstant
         getconstants = debug.getconstants

        local parryAnims = {
            ["rbxassetid://7009320896"] = { ["Guardbreak"] = false },
            ["rbxassetid://5087462384"] = { ["Guardbreak"] = false },
            ["rbxassetid://6501739912"] = { ["Guardbreak"] = false },
            ["rbxassetid://6704457409"] = { ["Guardbreak"] = false },
            ["rbxassetid://6718814119"] = { ["Guardbreak"] = false },
            ["rbxassetid://5029356929"] = { ["Guardbreak"] = false },
            ["rbxassetid://6930761828"] = { ["Guardbreak"] = false },
            ["rbxassetid://5087464114"] = { ["Guardbreak"] = false },
            ["rbxassetid://5029359784"] = { ["Guardbreak"] = false },
            ["rbxassetid://7876039532"] = { ["Guardbreak"] = false },
            ["rbxassetid://5810497127"] = { ["Guardbreak"] = false },
            ["rbxassetid://7891093418"] = { ["Guardbreak"] = false },
            ["rbxassetid://6930758587"] = { ["Guardbreak"] = false },
            ["rbxassetid://5110868660"] = { ["Guardbreak"] = false },
            ["rbxassetid://7877241063"] = { ["Guardbreak"] = false },
            ["rbxassetid://6550835152"] = { ["Guardbreak"] = false },
            ["rbxassetid://6604546413"] = { ["Guardbreak"] = false },
            ["rbxassetid://6875783564"] = { ["Guardbreak"] = false },
            ["rbxassetid://5052660577"] = { ["Guardbreak"] = false },
            ["rbxassetid://7877246443"] = { ["Guardbreak"] = false },
            ["rbxassetid://8594975706"] = { ["Guardbreak"] = false },
            ["rbxassetid://5865529031"] = { ["Guardbreak"] = false },
            ["rbxassetid://5116608619"] = { ["Guardbreak"] = false },
            ["rbxassetid://5110454001"] = { ["Guardbreak"] = false },
            ["rbxassetid://5092035643"] = { ["Guardbreak"] = false },
            ["rbxassetid://5869781872"] = { ["Guardbreak"] = false },
            ["rbxassetid://5110500012"] = { ["Guardbreak"] = false },
            ["rbxassetid://5645707634"] = { ["Guardbreak"] = false },
            ["rbxassetid://6718812539"] = { ["Guardbreak"] = false },
            ["rbxassetid://6194195462"] = { ["Guardbreak"] = false },
            ["rbxassetid://5110724393"] = { ["Guardbreak"] = false },
            ["rbxassetid://6930759930"] = { ["Guardbreak"] = false },
            ["rbxassetid://5883810295"] = { ["Guardbreak"] = false },
            ["rbxassetid://4918348016"] = { ["Guardbreak"] = false },
            ["rbxassetid://5092037778"] = { ["Guardbreak"] = false },
            ["rbxassetid://5052449595"] = { ["Guardbreak"] = false },
            ["rbxassetid://5087459369"] = { ["Guardbreak"] = false },
            ["rbxassetid://5873100725"] = { ["Guardbreak"] = false },
            ["rbxassetid://6573164932"] = { ["Guardbreak"] = false },
            ["rbxassetid://6566644368"] = { ["Guardbreak"] = false },
            ["rbxassetid://7791575394"] = { ["Guardbreak"] = false },
            ["rbxassetid://6360102363"] = { ["Guardbreak"] = false },
            ["rbxassetid://6719137742"] = { ["Guardbreak"] = false },
            ["rbxassetid://5052435233"] = { ["Guardbreak"] = false },
            ["rbxassetid://7876328758"] = { ["Guardbreak"] = false },
            ["rbxassetid://6875731587"] = { ["Guardbreak"] = false },
            ["rbxassetid://5126044328"] = { ["Guardbreak"] = false },
            ["rbxassetid://7887536058"] = { ["Guardbreak"] = false },
            ["rbxassetid://6674659296"] = { ["Guardbreak"] = false },
            ["rbxassetid://7130763680"] = { ["Guardbreak"] = false },
            ["rbxassetid://5092042225"] = { ["Guardbreak"] = false },
            ["rbxassetid://5110453274"] = { ["Guardbreak"] = false },
            ["rbxassetid://6360098898"] = { ["Guardbreak"] = false },
            ["rbxassetid://6704318501"] = { ["Guardbreak"] = false },
            ["rbxassetid://5870608112"] = { ["Guardbreak"] = false },
            ["rbxassetid://5126071335"] = { ["Guardbreak"] = false },
            ["rbxassetid://6257267175"] = { ["Guardbreak"] = false },
            ["rbxassetid://10234589242"] = { ["Guardbreak"] = false }, --Tiger Hunt
            ["rbxassetid://10234603041"] = { ["Guardbreak"] = true }, --Snake Bite
            ["rbxassetid://10261951458"] = { ["Guardbreak"] = false }, --Dragon Claw
            ["rbxassetid://5594891491"] = { ["Guardbreak"] = false }, --Bear Hug
            ["rbxassetid://7819569583"] = { ["Guardbreak"] = false }, --BlastCore
            ["rbxassetid://4901795168"] = { ["Guardbreak"] = true }, --brawl GB
            ["rbxassetid://4973374984"] = { ["Guardbreak"] = true }, --Thai GB
            ["rbxassetid://5016575571"] = { ["Guardbreak"] = true }, --Karate gb
            ["rbxassetid://6169229434"] = { ["Guardbreak"] = true }, --Wrestling GB
            ["rbxassetid://5016611308"] = { ["Guardbreak"] = true }, --Sumo GB
            ["rbxassetid://6538829055"] = { ["Guardbreak"] = true }, --Taek GB
            ["rbxassetid://6585959296"] = { ["Guardbreak"] = true }, --Raishin GB
            ["rbxassetid://6194191510"] = { ["Guardbreak"] = true }, --Kure GB
            ["rbxassetid://4918356164"] = { ["Guardbreak"] = true }, --Boxing GB
            ["rbxassetid://6169361647"] = { ["Guardbreak"] = true }, --Karate GB
        }

        local guardBreakTable = {
            ["Corkscrew"] = true,
            ["Blast Core"] = true,
            ["Flying Knee"] = true,
            ["Axe Kick"] = true,
            ["Tiger Bite"] = true,
            ["Reverse Heel"] = true,
            ["Solid Strike"] = true,
            ["Jolt Hook"] = true,
            ["Flying Side Kick"] = true,
            ["Sumo Throw"] = true,
            ["Bear Hug"] = true,
            ["Shoulder Bash"] = true,
            ["Forearm Smash"] = true,
            ["Suplex"] = true,
            ["Elbow Drop"] = 0.1,
            ["Body Slam"] = true,
            ["Eye Slice"] = true,
        }

        local function blockAttack()
            local key = getKey(plr.Backpack.LocalS)
            if not key then
                return
            end

            plr.Backpack.Action:FireServer(key, "Block", { true })
        end

        local function unblockAttack()
            local key = getKey(plr.Backpack.LocalS)
            if not key then
                return
            end

            plr.Backpack.Action:FireServer(key, "Block", { false })
        end

        local function guardBreak()
            local key = getKey(plr.Backpack.LocalS)
            if not key then
                return
            end

            plr.Backpack.Action:FireServer(key, "GuardBreak", { true })
        end

        getgenv().autoBlockconnections = {}

        local function autoParry(v)
            local plr = game.Players.LocalPlayer
            local char = plr.Character
            if v == char then
                return
            end

            local hrp = v:WaitForChild("HumanoidRootPart", 10)
            local animator = v:WaitForChild("Humanoid", 10) and v.Humanoid:WaitForChild("Animator", 10)
            if not hrp or not animator then
                return
            end

            getgenv().autoBlockconnections[#getgenv().autoBlockconnections + 1] = animator.AnimationPlayed:Connect(
                function(animationTrack)
                    local combat = GetStyle()
                    local animation = animationTrack.Animation
                    local id = animation.AnimationId
                    local tool = v:FindFirstChildWhichIsA("Tool")
                    local willGuardbreak = tool and guardBreakTable[tool.Name]

                    local distance = hrp.Parent and char and (hrp.Position - char.HumanoidRootPart.Position).magnitude
                    if
                        not distance
                        or distance > getgenv().ParryRange
                        or not parryAnims[id]
                        or not (math.random(1, 100) <= getgenv().ParryChance)
                    then
                        return
                    end

                    if willGuardbreak or parryAnims[id]["Guardbreak"] then
                        if char:FindFirstChild("Blocking") then
                            return combat:Activate()
                        end --If we already blocking then just parry?

                        if parryAnims[id]["Guardbreak"] then --Calculate speed
                            task.wait(animationTrack.Speed / 10)
                        end

                        blockAttack()

                        if getgenv().AutoCounter then
                            guardBreak()
                        end --This allows us to counter while blocking

                        combat:Activate()
                        task.wait(0.4)
                        unblockAttack()
                        return --We dont want to do anything else if they guardbreak
                    end

                    blockAttack()

                    if getgenv().AutoCounter then
                        guardBreak()
                    end --This allows us to counter while blocking

                    task.wait(0.4)
                    unblockAttack()
                end
            )
        end
        risky:AddLabel("-THESE ALL FROM AZTUP HUB NOT MINE-")
        risky:AddLabel("(aztup hub source is public to anyone)")

        risky:AddToggle({
            Name = "Auto Parry",
            Default = false,
            Save = true,
            Flag = "autoparry",
            Callback = function(Value)
                getgenv().AutoParry = Value

                if not getgenv().AutoParry then
                    for i, v in pairs(getgenv().autoBlockconnections) do
                        v:Disconnect()
                    end
                    return
                end

                for _, v in next, LivingThings:GetChildren() do
                    task.spawn(autoParry, v)
                end

                LivingThings.ChildAdded:Connect(autoParry)
            end
        })

        risky:AddSlider({
            Name = "AP Range",
            Min = 1,
            Max = 30,
            Default = 18,
            ValueName = "Value",
            Increment = 1,
            Color = Color3.fromRGB(230, 30, 13),
            Save = true,
            Flag = "aprange",
            Callback = function(Value)
                getgenv().ParryRange = Value
            end
        })

        risky:AddSlider({
            Name = "AP Chance",
            Min = 1,
            Max = 100,
            Default = 100,
            Increment = 1,
            Color = Color3.fromRGB(230, 30, 13),
            ValueName = "Value",
            Save = true,
            Flag = "apchance",
            Callback = function(Value)
                getgenv().ParryChance = Value
            end
        })

        risky:AddToggle({
            Name = "Auto Counter",
            Default = false,
            Save = true,
            Flag = "autocounter",
            Callback = function(Value)
                getgenv().AutoCounter = Value
            end
        })


        risky:AddToggle({
            Name = "Attach to Back (Mobs)",
            Default = ATBloop,
            Save = true,
            Flag = "attachtobackmobs",
            Callback = function(Value)
                getgenv().attachtoback = Value
        
                if ATBloop then
                    ATBloop:Disconnect()
                    ATBloop = nil
                end
        
                if not getgenv().attachtoback then
                    return
                end
        
                local plr = game.Players.LocalPlayer
                local char = plr.Character or plr.CharacterAdded:Wait()
                local lastcheck = 0
                local target = getMobInRange(ATBrange)
        
                ATBloop = game:GetService("RunService").Heartbeat:Connect(function()
                    if tick() - lastcheck >= 0.1 then
                        lastcheck = tick()
        
                        if target and target:FindFirstChild("KO") then
                            target = getMobInRange(ATBrange)
                            return
                        end
        
                        if not target or not target.Parent or not target:FindFirstChild("HumanoidRootPart") then
                            target = getMobInRange(ATBrange)
                            return
                        end
                    end
        
                    if char and char:FindFirstChild("HumanoidRootPart") and target then
                        char.HumanoidRootPart.CFrame = target.HumanoidRootPart.CFrame * (CFrame.new(0, ATBdistance, 1) * angleOffSet)
                        char.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero
                        char.HumanoidRootPart.AssemblyAngularVelocity = Vector3.zero
                    end
                end)
            end
        })
        

        risky:AddSlider({
            Name = "ATB Distance",
            Min = 1,
            Max = 50,
            Default = 5,
            Increment = 1,
            Color = Color3.fromRGB(230, 30, 13),
            ValueName = "Value",
            Save = true,
            Flag = "atbdistance",
            Callback = function(Value)
                ATBdistance = Value
            end
        })

        risky:AddSlider({
            Name = "ATB Range",
            Min = 0,
            Max = 100,
            Default = 100,
            Increment = 1,
            Color = Color3.fromRGB(230, 30, 13),
            ValueName = "Value",
            Save = true,
            Flag = "atbrange",
            Callback = function(Value)
                ATBrange = Value
            end
        })


        local RhythmLooping = false

        risky:AddToggle({
            Name = "Inf Rhythm",
            Default = false,
            Save = true,
            Flag = "infrhythm",
            Callback = function(Value)
                getgenv().InfRhythm = Value
                if not RhythmLooping and getgenv().InfRhythm then
                    local key = getKey(game.Players.LocalPlayer.Backpack.LocalS)
                    if not key then
                        return print("KEY NOT FOUND")
                    end
                    local action = game.Players.LocalPlayer.Backpack.Action
                    action:FireServer(key, "RhythmStance", true)
                    RhythmLooping = true
                    repeat
                        task.wait(0.1)
                    until not getgenv().InfRhythm
                    RhythmLooping = false
                    action:FireServer(key, "RhythmStance", false)
                end
            end
        })

        risky:AddToggle({
            Name = "Inf Dash",
            Default = false,
            Save = true,
            Flag = "infdash",
            Callback = function(Value)
                getgenv().InfDash = Value

                if getgenv().InfDash then
                    local env = getsenv(game.Players.LocalPlayer.Backpack.LocalS)
                    repeat
                        task.wait(0.1)
                        setupvalue(env.Dash, 2, 3)
                        setupvalue(env.Dash, 3, "")
                    until not getgenv().InfDash
                end
            end
        })

        risky:AddToggle({
            Name = "No Stam Dash",
            Default = false,
            Save = true,
            Flag = "nostamdash",
            Callback = function(Value)
                getgenv().NoStamDash = Value
                local env = getsenv(game.Players.LocalPlayer.Backpack.LocalS)
                local constantNum = ScanTable(getconstants(env.Dash), "FireServer")
                if not getgenv().NoStamDash then
                    setconstant(getsenv(plr.Backpack.LocalS).Dash, constantNum, "FireServer")
                    return
                end
                setconstant(getsenv(plr.Backpack.LocalS).Dash, constantNum, "GetChildren")
            end
        })

        local InfTreadLoop = false

        risky:AddToggle({
            Name = "Inf Treadmill Stamina",
            Default = false,
            Save = true,
            Flag = "inftreadmillstam",
            Callback = function(Value)
                getgenv().infTreadmillStamina = Value
            end
        })

        risky:AddBind({
            Name = "Inf Tread Bind",
            Default = Enum.KeyCode.Nine,
            Hold = false,
            Save = true,
            Flag = "inftreadbind",
            Callback = function()
                if getgenv().infTreadmillStamina and not InfTreadLoop then
                    getgenv().infTreadmillStaminaEnabled = true
                    InfTreadLoop = true

                    OrionLib:MakeNotification({
                        Name = "Inf Treadmill Stamina",
                        Content = tostring(getgenv().infTreadmillStaminaEnabled),
                        Image = "rbxassetid://4483345998",
                        Time = 5
                    })

                    local key = getKey(plr.Backpack.LocalS)

                    if key then
                        local action = plr.Backpack.Action
                        repeat
                            action:FireServer(key, "RunToggle", { [1] = true, [2] = false })
                            task.wait()
                            action:FireServer(key, "RunToggle", { false })
                            task.wait(0.3)
                        until not getgenv().infTreadmillStaminaEnabled or not getgenv().infTreadmillStamina
                    end
                    InfTreadLoop = false
                    getgenv().infTreadmillStaminaEnabled = false
                elseif getgenv().infTreadmillStamina and InfTreadLoop then
                    getgenv().infTreadmillStaminaEnabled = false
                    OrionLib:MakeNotification({
                        Name = "Inf Treadmill Stamina",
                        Content = tostring(getgenv().infTreadmillStaminaEnabled),
                        Image = "rbxassetid://4483345998",
                        Time = 5
                    })
                end
            end
        })

    end

    aztupInit = false

    if typeof(getgc) ~= "nil" then
        risky:AddButton({
            Name = "Aztup MO Features",
            Callback = function()
                if not getgenv().ACBYPASS then
                    local banRemote
                    local remoteKey

                    local plr = game.Players.LocalPlayer
                    local getupvalues = debug.getupvalues
                    local getconstant = debug.getconstant
                    local getconstants = debug.getconstants

                    local ran, err = pcall(function()
                        
                        local SHITEXPLOIT = false

                        local is_executor_closure = is_executor_closure or isexecutorclosure or is_synapse_function
                        if not is_executor_closure then
                            SHITEXPLOIT = true
                        end

                        local function initGC()
                            if SHITEXPLOIT then
                                remoteKey = ""
                                banRemote = game.ReplicatedStorage.Events:FindFirstChild("Detector")
                                return true
                            end
                            for _, v in next, getgc() do
                                local constants

                                local valid = pcall(function()
                                    if typeof(v) == "function" and islclosure(v) and not is_executor_closure(v) then
                                        constants = getconstants(v)
                                    end
                                end)

                                if constants ~= nil and valid then
                                    if ScanTable(constants, "F1ySuspicion") then
                                        banRemote = getconstant(v, ScanTable(getconstants(v), "F1ySuspicion") - 1)
                                        local remoteFolder = 24

                                        for _, uv in next, getupvalues(v) do
                                            if typeof(uv) == "string" then
                                                remoteKey = uv
                                            end
                                        end
                                        print(remoteKey)

                                        if getupvalue(v, remoteFolder + 1) ~= remoteKey then
                                            plr:Kick("Kicked you to protect your account, something in the game has changed.")
                                            return
                                        end

                                        if getupvalue(v, remoteFolder) and getupvalue(v, remoteFolder):FindFirstChild(banRemote) then
                                            banRemote = getupvalue(v, remoteFolder):FindFirstChild(banRemote)
                                            return true
                                        else
                                            return plr:Kick("Failed to grab ban remote")
                                        end
                                    end
                                end
                            end
                        end

                        repeat task.wait() until initGC()

                        if not banRemote or not remoteKey then
                            plr:Kick("Kicked you to protect your account, something in the game has changed.")
                            return
                        end

                        if banRemote.Name ~= "Detector" then
                            plr:Kick("Kicked you to protect your account, something in the game has changed.")
                            return
                        end

                        local oldNamecall
                        oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
                            local ncMethod = getnamecallmethod()
                            if (self == banRemote and (ncMethod == "FireServer" or ncMethod == "fireServer")) then
                                return
                            end
                            return oldNamecall(self, ...)
                        end)

                        local oldFireServer
                        oldFireServer = hookfunction(Instance.new("RemoteEvent").FireServer, function(self, ...)
                            if self == banRemote then
                                return
                            end
                            return oldFireServer(self, ...)
                        end)

                        getgenv().ACBYPASS = true
                    end)

                    if not ran then
                        warn(err)
                    end
                end

                if getgenv().ACBYPASS and not aztupInit then
                    aztupInit = true
                    AztupElements()
                end
            end
        })
    else
        risky:AddLabel({
            Name = "-- Unavailable on your Executor --"
        })
    end

    game.Players.PlayerAdded:Connect(function(v)
        if staffnotifier or copnotifier then
            N
